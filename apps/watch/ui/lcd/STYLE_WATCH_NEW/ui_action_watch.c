#include "app_config.h"
#include "ui/ui_style.h"
#include "ui/ui.h"
#include "ui/ui_api.h"
#include "app_task.h"
#include "system/timer.h"
#include "device/device.h"
#include "key_event_deal.h"
#include "res/resfile.h"
#include "ui/res_config.h"
#include "ui/ui_resource.h"
#include "font/language_list.h"
#include "sport/sport_api.h"
#include "ui/ui_measure.h"
#include "ui/ui_sys_param.h"
#include "btstack/avctp_user.h"
#include "message_vm_cfg.h"
#include "asm/math_fast_function.h"
#include "ui/result_pic_index.h"
#include "ui/result_str_index.h"
#include "gSensor/SL_Watch_Pedo_Kcal_Wrist_Sleep_Sway_Algorithm.h"
//#include "hx3605/hx3605.h"
#include "hrSensor_manage.h"

#if TCFG_UI_ENABLE && (!TCFG_LUA_ENABLE)
#ifdef CONFIG_UI_STYLE_JL_ENABLE

#define STYLE_NAME  JL

REGISTER_UI_STYLE(STYLE_NAME)

#define OLDER_STYLE (1)

static u16 watch_num_blue_timer = 0;
static u16 watch_num_green_timer = 0;
static u16 watch_num_red_timer = 0;
static u16 watch_progress_sleep_timer = 0;
static u16 watch_sleep_analysis_timer = 0;
static u16 watch_timer = 0;
static u16 watch_num_test_timer = 0;
static u16 watch_num_1_timer = 0;
static u16 watch_num_2_timer = 0;
static u16 watch_num_3_timer = 0;
static u16 watch_bt_compass_timer = 0;


extern void put_float(double fv);

void ui_page_list_init()
{
    ui_page_init();
    ui_page_add(PAGE_0);
    ui_page_add(PAGE_7);
    ui_page_add(PAGE_4);
    ui_page_add(PAGE_37);
    ui_page_add(PAGE_73);

    ui_page_list_all();
}

int ui_core_get_rtc_time(struct ui_time *time)
{
    struct sys_time sys_time = {0};
    void *fd = dev_open("rtc", NULL);
    if (!fd) {
        memset(time, 0, sizeof(*time));
        return -1;
    }
    dev_ioctl(fd, IOCTL_GET_SYS_TIME, (u32)&sys_time);
    time->year  =  sys_time.year;
    time->month = sys_time.month;
    time->day   = sys_time.day;
    time->hour  = sys_time.hour;
    time->min   = sys_time.min;
    time->sec   = sys_time.sec;
    /* g_printf("get_sys_time : %d-%d-%d,%d:%d:%d\n", time->year, time->month, time->day, time->hour, time->min, time->sec); */
    dev_close(fd);
    return 0;
}

#if OLDER_STYLE

struct progress_sleep_priv {
    int hour;
    int min;
    int sec;
    int target_hour;
};

struct progress_sleep_priv progress_sleep = {
    .target_hour = 8,
};

struct progress_record_priv {
    int steps;
    int target_steps;
    int min;
    int target_min;
    int times;
    int target_times;
};

struct progress_record_priv progress_record = {
    .target_steps = 1000,
    .target_min = 30,
    .target_times = 12,
};

// static void NUM_BLUE_timer(void *priv)
// {
//     static int last_percent = 0;
//     struct progress_record_priv *this = (struct progress_record_priv *)priv;
//     int percent;
//     static struct unumber n;

//     if (!watch_num_blue_timer) {
//         return ;
//     }
//     ui_io_set(IO_FRAME, HIGH);

//     this->steps++;
//     if (this->steps > 1000) {
//         this->steps = 0;
//     }

//     n.type = TYPE_NUM;
//     n.numbs = 1;
//     n.number[0] = this->steps;
//     ui_number_update_by_id(NUM_BLUE, &n);
//     percent = this->steps * 100 / this->target_steps;
//     if (last_percent != percent) {
//         ui_multiprogress_set_persent_by_id(MULTI_PROGRESS, percent);
//         last_percent = percent;
//     }

//     ui_io_set(IO_FRAME, LOW);
// }





// static int NUM_BLUE_onchange(void *_number, enum element_change_event event, void *arg)
// {
//     struct ui_number *number = (struct ui_number *)_number;

//     switch (event) {
//     case ON_CHANGE_INIT:
//         progress_record.steps = 0;
//         number->nums = 1;
//         number->number[0] = progress_record.steps;

//         if (!watch_num_blue_timer) {
//             watch_num_blue_timer = sys_timer_add(&progress_record, NUM_BLUE_timer, 1000);
//         }
//         break;
//     case ON_CHANGE_RELEASE:
//         if (watch_num_blue_timer) {
//             sys_timer_del(watch_num_blue_timer);
//             watch_num_blue_timer = 0;
//         }
//         break;
//     default:
//         return FALSE;
//     }
//     return FALSE;
// }
static unsigned int step_not_clear;
static void NUM_BLUE_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_blue_timer) {
        return ;
    }
    ui_io_set(IO_FRAME, HIGH);
	this->steps+=get_step_count();
   	step_not_clear+=get_step_count();
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = step_not_clear;
    ui_number_update_by_id(NUM_BLUE, &n);//刷新
    percent = step_not_clear * 100 / this->target_steps;
    ui_multiprogress_set_persent_by_id(MULTI_PROGRESS, percent);

    ui_io_set(IO_FRAME, LOW);
}

static int NUM_BLUE_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.steps = 0;
        number->nums = 1;
        number->number[0] = progress_record.steps;

        if (!watch_num_blue_timer) {
            watch_num_blue_timer = sys_timer_add(&progress_record, NUM_BLUE_timer, 500);
        }
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(NUM_BLUE)
.onchange = NUM_BLUE_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
//-----------------//

static void NUM_GREEN_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_green_timer) {
        return ;
    }
    ui_io_set(IO_FRAME, HIGH);

    this->min++;
    if (this->min > 30) {
        this->min = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = this->min;
    ui_number_update_by_id(NUM_GREEN_1, &n);
    n.number[0] = this->target_min;
    ui_number_update_by_id(NUM_GREEN_2, &n);
    percent = this->min * 100 / this->target_min;
    if (last_percent != percent) {
        ui_multiprogress_set_second_persent_by_id(MULTI_PROGRESS, percent);
        last_percent = percent;
    }

    ui_io_set(IO_FRAME, LOW);
}

static int NUM_GREEN_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.min = 0;
        progress_record.target_min = 30;
        number->nums = 2;
        number->number[0] = progress_record.min;
        number->number[1] = progress_record.target_min;
        if (!watch_num_green_timer) {
            watch_num_green_timer = sys_timer_add(&progress_record, NUM_GREEN_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_green_timer) {
            sys_timer_del(watch_num_green_timer);
            watch_num_green_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(NUM_GREEN_1)
.onchange = NUM_GREEN_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

static void NUM_RED_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_red_timer) {
        return;
    }
    ui_io_set(IO_FRAME, HIGH);

    this->times++;
    if (this->times > 12) {
        this->times = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = this->times;
    ui_number_update_by_id(NUM_RED_1, &n);
    n.number[0] = this->target_times;
    ui_number_update_by_id(NUM_RED_2, &n);

    percent = this->times * 100 / this->target_times;
    if (last_percent != percent) {
        ui_multiprogress_set_third_persent_by_id(MULTI_PROGRESS, percent);
        last_percent = percent;
    }

    ui_io_set(IO_FRAME, LOW);
}

static int NUM_RED_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;
    static int timer = 0;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.times = 0;
        progress_record.target_times = 12;
        number->nums = 2;
        number->number[0] = progress_record.times;
        number->number[1] = progress_record.target_times;
        if (!watch_num_red_timer) {
            watch_num_red_timer = sys_timer_add(&progress_record, NUM_RED_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_red_timer) {
            sys_timer_del(watch_num_red_timer);
            watch_num_red_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(NUM_RED_1)
.onchange = NUM_RED_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


static int TARGET_NUM_HOUR_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        number->nums = 1;
        number->number[0] = progress_sleep.target_hour;
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(TARGET_SLEEP_HOUR)
.onchange = TARGET_NUM_HOUR_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif

static void PROGRESS_SLEEP_timer(void *priv)
{
    if (!watch_progress_sleep_timer) {
        return ;
    }

#if OLDER_STYLE
    static int last_hour = 0;
    static int last_min = 0;
    static int last_percent = 0;
    int percent = 0;
	static char sleep_hrs_result = 0;
	static char sleep_wear_result = 0;
	static char sleep_sec = 0;
    struct progress_sleep_priv *this = (struct progress_sleep_priv *)priv;

    /* if (++this->sec >= 60) { */
    /* this->sec = 0; */
    /* if (++this->min >= 60) { */
    /* this->min = 0; */
    /* if (++this->hour >= 12) { */
    /* this->hour = 0; */
    /* } */
    /* } */
    /* } */
	printf("PROGRESS_SLEEP_timer====");
	if(1/*get_sleep_status()*/)
	{
	    printf("PROGRESS_SLEEP_timer====111");
        #if TCFG_HRS3605_EN || TCFG_HRS1662_EN
        if(!get_hrs_enable_status())
		{
			printf("PROGRESS_SLEEP_timer====222");
			hr_sensor_io_ctl(HR_SENSOR_DISABLE, NULL);
			hr_sensor_io_ctl(HR_SENSOR_ENABLE, NULL);
		}
	    sleep_hrs_result = get_hrs_results();//getCurrentHR(whr.workbuf);//实时调取心率
	    sleep_wear_result = get_hrs_wear_results();
        #else
        sleep_hrs_result = 78;
        sleep_wear_result = 1;
        #endif
		printf("hrs %d wear %d",sleep_hrs_result,sleep_wear_result);
		if(sleep_wear_result)
		{
		sleep_sec++;
		if(sleep_sec>=60)
			{
			sleep_sec = 0;
			this->min++;
		}
		}
	}
	else{
         #if TCFG_HRS3605_EN || TCFG_HRS1662_EN
		if(get_hrs_enable_status()){
		hr_sensor_io_ctl(HR_SENSOR_DISABLE, NULL);
		}
        #endif
	}
    //test
    //this->min += 10;
    printf("this->min %d",this->min);
    if (this->min >= 60) {
        this->min = 0;
        this->hour++;
        /* if (this->hour >= 8) { */
        /* this->hour = 0; */
        /* } */
    }

    if ((this->hour == 8) && (this->min == 10)) {
        this->hour = 0;
        this->min = 0;
    }

    if (last_hour != this->hour) {
        struct unumber numb_hour;
        numb_hour.type = TYPE_NUM;
        numb_hour.numbs = 1;
        numb_hour.number[0] = this->hour;
        ui_number_update_by_id(SLEEP_HOUR, &numb_hour);

        last_hour = this->hour;
    }

    if (last_min != this->min) {
        struct unumber numb_min;
        numb_min.type = TYPE_NUM;
        numb_min.numbs = 1;
        numb_min.number[0] = this->min;
        ui_number_update_by_id(SLEEP_MIN, &numb_min);

        last_min = this->min;
    }

    percent = (this->hour * 3600 + this->min * 60 + this->sec) / (8 * 36);
    if (last_percent != percent) {
        ui_io_set(IO_FRAME, HIGH);
        ui_progress_set_persent_by_id(PROGRESS_SLEEP, percent);
        ui_io_set(IO_FRAME, LOW);
        last_percent = percent;
    }
#else
	printf("PROGRESS_SLEEP_timer====22222222222222222222");

    ui_update_source_by_elm(priv, 1);

#endif
}
// static void PROGRESS_SLEEP_timer(void *priv)
// {
//     if (!watch_progress_sleep_timer) {
//         return ;
//     }

// #if OLDER_STYLE
//     static int last_hour = 0;
//     static int last_min = 0;
//     static int last_percent = 0;
//     int percent = 0;
//     struct progress_sleep_priv *this = (struct progress_sleep_priv *)priv;

//     /* if (++this->sec >= 60) { */
//     /* this->sec = 0; */
//     /* if (++this->min >= 60) { */
//     /* this->min = 0; */
//     /* if (++this->hour >= 12) { */
//     /* this->hour = 0; */
//     /* } */
//     /* } */
//     /* } */

//     //test
//     this->min += 10;
//     if (this->min >= 60) {
//         this->min = 0;
//         this->hour++;
//         /* if (this->hour >= 8) { */
//         /* this->hour = 0; */
//         /* } */
//     }

//     if ((this->hour == 8) && (this->min == 10)) {
//         this->hour = 0;
//         this->min = 0;
//     }

//     if (last_hour != this->hour) {
//         struct unumber numb_hour;
//         numb_hour.type = TYPE_NUM;
//         numb_hour.numbs = 1;
//         numb_hour.number[0] = this->hour;
//         ui_number_update_by_id(SLEEP_HOUR, &numb_hour);

//         last_hour = this->hour;
//     }

//     if (last_min != this->min) {
//         struct unumber numb_min;
//         numb_min.type = TYPE_NUM;
//         numb_min.numbs = 1;
//         numb_min.number[0] = this->min;
//         ui_number_update_by_id(SLEEP_MIN, &numb_min);

//         last_min = this->min;
//     }

//     percent = (this->hour * 3600 + this->min * 60 + this->sec) / (8 * 36);
//     if (last_percent != percent) {
//         ui_io_set(IO_FRAME, HIGH);
//         ui_progress_set_persent_by_id(PROGRESS_SLEEP, percent);
//         ui_io_set(IO_FRAME, LOW);
//         last_percent = percent;
//     }
// #else

//     ui_update_source_by_elm(priv, 1);

// #endif
// }


static int PROGRESS_SLEEP_onchange(void *ctr, enum element_change_event e, void *arg)
{
    int index;
    struct ui_progress *progress = (struct ui_progress *)ctr;

    switch (e) {
    case ON_CHANGE_INIT:
#if OLDER_STYLE
        progress_sleep.hour = 0;
        progress_sleep.min = 0;
        progress_sleep.sec = 0;
        if (!watch_progress_sleep_timer) {
            watch_progress_sleep_timer = sys_timer_add(&progress_sleep, PROGRESS_SLEEP_timer, 1000);
        }
#else
        if (!watch_progress_sleep_timer) {
            watch_progress_sleep_timer = sys_timer_add(ctr, PROGRESS_SLEEP_timer, 1000);
        }
#endif
        break;
    case ON_CHANGE_RELEASE:
        if (watch_progress_sleep_timer) {
            sys_timer_del(watch_progress_sleep_timer);
            watch_progress_sleep_timer = 0;
        }
        break;
    case ON_CHANGE_FIRST_SHOW:
#if (!OLDER_STYLE)
        ui_update_source_by_elm(ctr, 0);
#endif
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
int PROGRESS_SLEEP_ontouch(void *_layout, struct element_touch_event *e)
{
    struct layout *layout = (struct layout *)_layout;

    switch (e->event) {
    case ELM_EVENT_TOUCH_R_MOVE:
        ui_return_page_pop(1);
    //return false;
    case ELM_EVENT_TOUCH_L_MOVE:
        ui_return_page_pop(0);
    //return false;
    default:
        break;
    }
    return false;
}
REGISTER_UI_EVENT_HANDLER(PROGRESS_SLEEP)
.onchange = PROGRESS_SLEEP_onchange,
 .onkey = NULL,
  .ontouch = PROGRESS_SLEEP_ontouch,
};
void refresh_sleep_analysis(void *priv)
{
    if (!watch_sleep_analysis_timer) {
        return ;
    }
    watch_sleep_analysis_timer = 0;
    printf("%s", __func__);
#if 1
    struct unumber deep_score;
    deep_score.type = TYPE_NUM;
    deep_score.numbs = 1;
    deep_score.number[0] = 65;
    ui_number_update_by_id(DEEP_SLEEP_SCORE_NUM, &deep_score);
    struct unumber shallow_score;
    shallow_score.type = TYPE_NUM;
    shallow_score.numbs = 1;
    shallow_score.number[0] = 35;
    ui_number_update_by_id(SHALLOW_SLEEP_SCORE_NUM, &shallow_score);
    struct unumber rem_score;
    rem_score.type = TYPE_NUM;
    rem_score.numbs = 1;
    rem_score.number[0] = 5;
    ui_number_update_by_id(REM_SLEEP_SCORE_NUM, &rem_score);

    struct unumber all_score;
    all_score.type = TYPE_NUM;
    all_score.numbs = 1;
    all_score.number[0] = 60;
    ui_number_update_by_id(ALL_SLEEP_SCORE_NUM, &all_score);

    struct unumber continue_score;
    continue_score.type = TYPE_NUM;
    continue_score.numbs = 1;
    continue_score.number[0] = 80;
    ui_number_update_by_id(SLEEP_CONTINUE_SCORE_NUM, &continue_score);
    if (deep_score.number[0] > 60) {
        ui_text_show_index_by_id(DEEP_SLEEP_TEXT, 3);
    } else if (deep_score.number[0] < 20) {
        ui_text_show_index_by_id(DEEP_SLEEP_TEXT, 1);
    } else {
        ui_text_show_index_by_id(DEEP_SLEEP_TEXT, 2);
    }

    if (shallow_score.number[0] < 55) {
        ui_text_show_index_by_id(SHALLOW_SLEEP_TEXT, 2);
    } else {
        ui_text_show_index_by_id(SHALLOW_SLEEP_TEXT, 3);
    }

    if (rem_score.number[0] > 30) {
        ui_text_show_index_by_id(REM_SLEEP_TEXT, 3);
    } else if (rem_score.number[0] < 10) {
        ui_text_show_index_by_id(REM_SLEEP_TEXT, 1);
    } else {
        ui_text_show_index_by_id(REM_SLEEP_TEXT, 2);
    }



#else


#endif
}

static int SLEEP_ANALYSIS_onchange(void *ctr, enum element_change_event e, void *arg)
{

    switch (e) {
    case ON_CHANGE_INIT:
        if (!watch_sleep_analysis_timer) {
            watch_sleep_analysis_timer = sys_timeout_add(NULL, refresh_sleep_analysis, 10);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_sleep_analysis_timer) {
            sys_timeout_del(watch_sleep_analysis_timer);
            watch_sleep_analysis_timer = 0;
        }
        break;
    case ON_CHANGE_FIRST_SHOW:

        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(SLEEP_ANALYSIS_LAYOUT)
.onchange = SLEEP_ANALYSIS_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};




#if (!OLDER_STYLE)

REGISTER_UI_EVENT_HANDLER(MULTI_PROGRESS)
.onchange = PROGRESS_SLEEP_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#else

REGISTER_UI_EVENT_HANDLER(MULTI_PROGRESS)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = PROGRESS_SLEEP_ontouch,
};

#endif


static void get_sys_time(struct sys_time *time)
{
    void *fd = dev_open("rtc", NULL);
    if (!fd) {
        memset(time, 0, sizeof(*time));
        return;
    }
    dev_ioctl(fd, IOCTL_GET_SYS_TIME, (u32)time);
    /* printf("get_sys_time : %d-%d-%d,%d:%d:%d\n", time->year, time->month, time->day, time->hour, time->min, time->sec); */
    dev_close(fd);
}

#if 0
int ui_get_child_by_id(int id);
static void WATCH_timer(void *priv)
{
    if (!watch_timer) {
        return ;
    }
    struct watch_priv *this = (struct watch_priv *)priv;
    struct sys_time time;
    int id;

    get_sys_time(&time);
    //printf("%04d-%02d-%02d %02d:%02d:%02d\n",time.year,time.month,time.day,time.hour,time.min,time.sec);
    this->hour = time.hour % 12;
    this->min  = time.min;
    this->sec  = time.sec;
    ui_watch_set_time_by_id(STYLE_WATCH_ID(WATCH), this->hour, this->min, this->sec);

    id = STYLE_WATCH_ID(WATCH);
    printf("root id = 0x%x\n", id);
    ui_get_child_by_id(id);
}


static int WATCH_onchange(void *ctr, enum element_change_event e, void *arg)
{
    int index;
    struct ui_watch *watch = (struct ui_watch *)ctr;
    struct sys_time time;

    switch (e) {
    case ON_CHANGE_INIT:
        get_sys_time(&time);
        watch->hour = time.hour % 12;
        watch->min  = time.min;
        watch->sec  = time.sec;
        if (!watch_timer) {
            watch_timer = sys_timer_add(&watch_t, WATCH_timer, 200);
        }
        break;
    case ON_CHANGE_SHOW:
        break;
    case ON_CHANGE_RELEASE:
        if (watch_timer) {
            sys_timer_del(watch_timer);
            watch_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_DIAL_UI_EVENT_HANDLER(WATCH)
.onchange = WATCH_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif





void ui_send_event(u16 event, u32 val)
{
    struct sys_event e;
    e.type = SYS_KEY_EVENT;
    e.u.key.event = event;
    e.u.key.value = val;
    sys_event_notify(&e);
}

int PAGE_switch_ontouch(void *_layout, struct element_touch_event *e)
{
    struct layout *layout = (struct layout *)_layout;

    switch (e->event) {
    case ELM_EVENT_TOUCH_R_MOVE:
        /* ui_return_page_pop(1); */
        return false;
    case ELM_EVENT_TOUCH_L_MOVE:
        /* ui_return_page_pop(0); */
        return false;
    default:
        break;
    }
    return false;
}

static int test_handler(const char *type, u32 arg)
{
    printf("msg test %s %s %d \n", __FUNCTION__, type, arg);
    return 0;
}


static const struct uimsg_handl ui_msg_handler[] = {
    { "test1",        test_handler     }, /* 设置音量 */
    { "test2",        test_handler     }, /* 设置音量 */
    { "test3",        test_handler     }, /* 设置音量 */
    { "test4",        test_handler     }, /* 设置音量 */
    { NULL, NULL},      /* 必须以此结尾！ */
};

static int PAGE_mode_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct window *window = (struct window *)ctr;
    printf("window call = %s id =%x \n", __FUNCTION__, window->elm.id);
    switch (e) {
    case ON_CHANGE_INIT:
        ui_register_msg_handler(window->elm.id, ui_msg_handler);//注册消息交互的回调
        break;
    case ON_CHANGE_RELEASE:

        break;
    default:
        return false;
    }
    return false;
}
#if 0
REGISTER_DIAL_UI_EVENT_HANDLER(PAGE_0)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};
#endif

REGISTER_UI_EVENT_HANDLER(PAGE_0)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};

REGISTER_UI_EVENT_HANDLER(PAGE_1)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};

REGISTER_UI_EVENT_HANDLER(PAGE_2)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};

REGISTER_UI_EVENT_HANDLER(PAGE_3)
.onchange = PAGE_mode_onchange,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};

/* REGISTER_UI_EVENT_HANDLER(PAGE_7) */
/* .onchange = NULL, */
/*  .onkey = NULL, */
/*   .ontouch = PAGE_switch_ontouch, */
/* }; */

REGISTER_UI_EVENT_HANDLER(PAGE_9)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};

REGISTER_UI_EVENT_HANDLER(PAGE_13)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};

REGISTER_UI_EVENT_HANDLER(PAGE_37)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = PAGE_switch_ontouch,
};


struct dial_info {
    char number[32];
    int index;
};
struct dial_info dial_info_t = {0};


static void dial_add_number(char ch)
{
    static struct unumber n;

    if (dial_info_t.index >= 19) {
        return;
    }
    dial_info_t.number[dial_info_t.index++] = ch;
    dial_info_t.number[dial_info_t.index] = '\0';
    n.type = TYPE_STRING;
    n.num_str = (u8 *)dial_info_t.number;
    /* g_printf("%s",n.num_str); */
    ui_number_update_by_id(DIAL_NUM, &n);
}

static void dial_remove_number()
{
    static struct unumber n;

    if (dial_info_t.index <= 0) {
        return;
    }
    dial_info_t.number[--dial_info_t.index] = '\0';
    n.type = TYPE_STRING;
    n.num_str = (u8 *)dial_info_t.number;
    /* r_printf("%s",n.num_str); */
    ui_number_update_by_id(DIAL_NUM, &n);
}

static int DIAL_Common_ontouch(void *ctrl, struct element_touch_event *e)
{
    struct element *elm = (struct element *)ctrl;

    switch (e->event) {
    case ELM_EVENT_TOUCH_DOWN:
        switch (elm->id) {
        case DIAL_EXIT:
            printf("[5]DIAL_EXIT DOWN\n");
            break;
        case DIAL_DEL:
            printf("[5]DIAL_DEL DOWN\n");
            break;
        case DIAL_0:
            printf("[5]DIAL_0 DOWN\n");
            break;
        case DIAL_1:
            printf("[5]DIAL_1 DOWN\n");
            break;
        case DIAL_2:
            printf("[5]DIAL_2 DOWN\n");
            break;
        case DIAL_3:
            printf("[5]DIAL_3 DOWN\n");
            break;
        case DIAL_4:
            printf("[5]DIAL_4 DOWN\n");
            break;
        case DIAL_5:
            printf("[5]DIAL_5 DOWN\n");
            break;
        case DIAL_6:
            printf("[5]DIAL_6 DOWN\n");
            break;
        case DIAL_7:
            printf("[5]DIAL_7 DOWN\n");
            break;
        case DIAL_8:
            printf("[5]DIAL_8 DOWN\n");
            break;
        case DIAL_9:
            printf("[5]DIAL_9 DOWN\n");
            break;
        case DIAL_CTL:
            printf("[5]DIAL_CTL DOWN\n");
            break;
        case DIAL_CALL:
            printf("[5]DIAL_CALL DOWN\n");
            break;
        default:
            break;
        }
        /* ui_core_highlight_element(elm, true); */
        ui_core_redraw(elm);
        return true;
    case ELM_EVENT_TOUCH_UP:
        switch (elm->id) {
        case DIAL_EXIT:
            printf("[5]DIAL_EXIT UP\n");
            dial_add_number('*');
            break;
        case DIAL_DEL:
            printf("[5]DIAL_DEL UP\n");
            dial_remove_number();
            break;
        case DIAL_0:
            printf("[5]DIAL_0 UP\n");
            dial_add_number('0');
            break;
        case DIAL_1:
            printf("[5]DIAL_1 UP\n");
            dial_add_number('1');
            break;
        case DIAL_2:
            printf("[5]DIAL_2 UP\n");
            dial_add_number('2');
            break;
        case DIAL_3:
            printf("[5]DIAL_3 UP\n");
            dial_add_number('3');
            break;
        case DIAL_4:
            printf("[5]DIAL_4 UP\n");
            dial_add_number('4');
            break;
        case DIAL_5:
            printf("[5]DIAL_5 UP\n");
            dial_add_number('5');
            break;
        case DIAL_6:
            printf("[5]DIAL_6 UP\n");
            dial_add_number('6');
            break;
        case DIAL_7:
            printf("[5]DIAL_7 UP\n");
            dial_add_number('7');
            break;
        case DIAL_8:
            printf("[5]DIAL_8 UP\n");
            dial_add_number('8');
            break;
        case DIAL_9:
            printf("[5]DIAL_9 UP\n");
            dial_add_number('9');
            break;
        case DIAL_CTL:
            printf("[5]DIAL_CTL UP\n");
            dial_add_number(' ');
            break;
        case DIAL_CALL:
            printf("[5]DIAL_CALL UP\n");
            struct phonebook message;
            if (get_bt_connect_status() !=  BT_STATUS_WAITINT_CONN) {
                int len = phonebook_get_name_by_number(dial_info_t.number, message.name);
                if (len == 0) {
                    sprintf(message.name, "%s", "unknow");
                }
                set_call_log_message(1, message.name, message.number, NULL);
                user_send_cmd_prepare(USER_CTRL_DIAL_NUMBER, dial_info_t.index, dial_info_t.number);
            }
            break;
        default:
            break;
        }
        /* ui_core_highlight_element(elm, false); */
        ui_core_redraw(elm);

        break;
    default:
        break;
    }
    return true;
}

REGISTER_UI_EVENT_HANDLER(DIAL_EXIT)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};

REGISTER_UI_EVENT_HANDLER(DIAL_DEL)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_0)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_1)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_2)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_3)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_4)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_5)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_6)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_7)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_8)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_9)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_CTL)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL_CALL)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = DIAL_Common_ontouch,
};

static int DIAL_NUM_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_ctrl;

    switch (event) {
    case ON_CHANGE_INIT:
        dial_info_t.index = 0;
        dial_info_t.number[dial_info_t.index] = '\0';
        /* ui_number_update(number, dial_info_t.number); */
        number->type = TYPE_STRING;
        number->num_str = (u8 *)dial_info_t.number;
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(DIAL_NUM)
.onchange = DIAL_NUM_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

/*文本控件多字符串组合显示示例*/
static int BASEFORM_238_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;
    u8 index_buf[3];
    static u16 store_buf[4];

    switch (event) {
    case ON_CHANGE_INIT:
        /* 一二三四五六日 */
        index_buf[0] = 0;//一
        index_buf[1] = 2;//三
        index_buf[2] = 4;//五
        ui_text_set_combine_index(text, store_buf, index_buf, 3);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


/* REGISTER_UI_EVENT_HANDLER(BASEFORM_238) */
/* .onchange = BASEFORM_238_onchange, */
/* .onkey = NULL, */
/* .ontouch = NULL, */
/* }; */

#define MAX_BGP_GRID_ITEM       (10)
static int cur_grid_watch = 0;

extern u32 watch_bgp_get_nums();
extern char *watch_bgp_get_item(u8 sel_item);
extern int watch_bgp_set_related(char *bgp, u8 cur_watch, u8 del);

static int WATCH_BGP_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_grid *grid = (struct ui_grid *)_ctrl;
    int items_num = 0;

    switch (event) {
    case ON_CHANGE_INIT_PROBE:
        items_num = watch_bgp_get_nums() + 1;
        items_num = (items_num >= MAX_BGP_GRID_ITEM) ? MAX_BGP_GRID_ITEM : items_num;
        items_num = (items_num == 0) ? 1 : items_num;

        printf("grid num %d\n", items_num);
        ui_grid_set_item_num(grid, items_num);//修改列表条目数量,不能超过列表的最大数量
        break;
    default:
        break;
    }
    return 0;
}

static int WATCH_BGP_ontouch(void *ctr, struct element_touch_event *e)
{
    struct ui_grid *grid = (struct ui_grid *)ctr;
    static u8 touch_action = 0;
    int sel_item;
    int ret;
    char *bgp = NULL;

    switch (e->event) {
    case ELM_EVENT_TOUCH_UP:

        sel_item = ui_grid_cur_item(grid);
        printf("watch_sel_bgp %d, %d\n", sel_item, touch_action);
        if (touch_action != 1) {
            break;
        }

        if (sel_item > 0) {
            bgp = watch_bgp_get_item(sel_item - 1);
            bgp = &bgp[strlen(RES_PATH)];
        }
        ret = watch_bgp_set_related(bgp, cur_grid_watch, 0);
        if (ret != 0) {
            printf("watch_set_style err %d\n", sel_item);
            break;
        }

        ui_send_event(KEY_CHANGE_PAGE, BIT(31) | PAGE_16);
        break;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:
        touch_action = 2;
        break;
    case ELM_EVENT_TOUCH_DOWN:
        touch_action = 1;
        break;
    case ELM_EVENT_TOUCH_U_MOVE:
        break;
    case ELM_EVENT_TOUCH_D_MOVE:
        break;
    default:
        break;
    }

    return false;
}


REGISTER_UI_EVENT_HANDLER(WATCH_HLIST_BGP)
.onchange = WATCH_BGP_onchange,
 .onkey = NULL,
  .ontouch = WATCH_BGP_ontouch,
};

static int BGP_PREVIEW_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_pic *pic = (struct ui_pic *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    static RESFILE *bgp_file[MAX_BGP_GRID_ITEM] = {0};
    static u32 open_flag = 0;
    int sel_item;
    char *watch_bgp_item;

    switch (event) {
    case ON_CHANGE_INIT:

        int items_num = 0;

        if (open_flag) {
            break;
        }
        items_num = watch_bgp_get_nums();
        items_num = (items_num >= MAX_BGP_GRID_ITEM) ? MAX_BGP_GRID_ITEM : items_num;
        for (sel_item = 0; sel_item < items_num; sel_item++) {
            watch_bgp_item = watch_bgp_get_item(sel_item);
            if (watch_bgp_item == NULL) {
                printf("prew get item err %d\n", sel_item);
                return FALSE;
            }
            bgp_file[sel_item] = res_fopen(watch_bgp_item, "r");
            if (!bgp_file[sel_item]) {
                printf("open_bgp_prewfile fail %s\n", watch_bgp_item);
                return FALSE;
            }
            printf("prew out\n");
        }
        open_flag = 1;

        break;
    case ON_CHANGE_SHOW:

        switch (pic->elm.id) {
        case BGP_0:
            sel_item = 0;
            break;
        case BGP_1:
            sel_item = 1;
            break;
        case BGP_2:
            sel_item = 2;
            break;
        case BGP_3:
            sel_item = 3;
            break;
        case BGP_4:
            sel_item = 4;
            break;
        case BGP_5:
            sel_item = 5;
            break;
        case BGP_6:
            sel_item = 6;
            break;
        case BGP_7:
            sel_item = 7;
            break;
        case BGP_8:
            sel_item = 8;
            break;
        default:
            return FALSE;
        }

        if ((sel_item >= watch_bgp_get_nums()) || (bgp_file[sel_item] == NULL)) {
            printf("select bgp preview err1 %x, %d\n", pic->elm.id, sel_item);
            return FALSE;
        }
        pic->elm.css.background_image = 1;
        dc->preview.file = bgp_file[sel_item];

        dc->preview.id = 1;
        dc->preview.page = 0;
        break;
    case ON_CHANGE_RELEASE:

        for (sel_item = 0; sel_item < MAX_BGP_GRID_ITEM; sel_item++) {
            if (bgp_file[sel_item]) {
                res_fclose(bgp_file[sel_item]);
                bgp_file[sel_item] = NULL;
            }
        }
        open_flag = 0;

        break;
    default:
        break;
    }

    return 0;
}

REGISTER_UI_EVENT_HANDLER(BGP_NULL)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_0)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_1)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_2)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_3)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_4)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_5)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_6)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_7)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(BGP_8)
.onchange = BGP_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};









#define MAX_GRID_ITEM       (6)
extern int watch_set_style(int style);
extern int watch_get_items_num();
extern char *watch_get_item(int style);
extern int watch_version_juge(char *watch_item);
extern int watch_get_style();

//判断是否当前表盘是否支持多功能拓展 由用户进行判断依据
//这里先默认表盘0是支持的
static int IS_watch_support_expand(int style)
{
    if (style == 0) {
        return false;
    } else {
        return false;
    }
}


static int watch_list_children_init(struct ui_grid *grid)
{
    struct element *k;
    if (!grid) {
        return 0;
    }

    for (int i = 0; i < grid->avail_item_num; i++) {
        list_for_each_child_element(k, &grid->item[i].elm) {
            switch (ui_id2type(k->id)) {
            case CTRL_TYPE_TEXT:
                struct ui_text *text = (struct ui_text *)k;
                if (!strcmp(text->source, "expand")) {
                    if (IS_watch_support_expand(i)) {
                        text->elm.css.invisible = 0;
                    } else {
                        text->elm.css.invisible = 1;
                    }
                }
                break;
            }
        }
    }
    return 0;
}


static int WATCH_VERTLIST_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_grid *grid = (struct ui_grid *)_ctrl;
    int items_num = 0;

    switch (event) {
    case ON_CHANGE_INIT_PROBE:
        items_num = watch_get_items_num();
        items_num = (items_num >= MAX_GRID_ITEM) ? MAX_GRID_ITEM : items_num;
        grid_energy_auto_center(grid, 1);
        printf("grid num %d\n", items_num);
        ui_grid_set_item_num(grid, items_num);//修改列表条目数量,不能超过列表的最大数量
        break;
    case ON_CHANGE_FIRST_SHOW:
        watch_list_children_init(grid);//初始化一些功能表盘按钮
        break;
    default:
        break;
    }
    return 0;
}

static int WATCH_VERTLIST_ontouch(void *ctr, struct element_touch_event *e)
{
    struct ui_grid *grid = (struct ui_grid *)ctr;
    static u8 touch_action = 0;
    int sel_item;
    int ret;
    switch (e->event) {
    case ELM_EVENT_TOUCH_UP:

        if (touch_action != 1) {
            break;
        }

        sel_item = ui_grid_cur_item(grid);
        printf("watch_set_style %d\n", sel_item);

        ret = watch_version_juge(watch_get_item(sel_item));
        if (ret != 0) {
            break;
        }

        ret = watch_set_style(sel_item);
        if (ret != true) {
            printf("watch_set_style err %d\n", sel_item);
            break;
        }

        struct rect r;
        struct element *p, *n;
        struct element *elm = &grid->item[sel_item].elm;
        list_for_each_child_element_reverse(p, n, elm) {
            struct ui_text *text = (struct ui_text *)p;
            if (!p->css.invisible && ((ui_id2type(p->id)) == CTRL_TYPE_TEXT) && !strcmp(text->source, "expand")) { //判断是否字符控件以及是否可见
                ui_core_get_element_abs_rect(p, &r);
                if (in_rect(&r, &e->pos)) {
                    printf("<<<<< __FUNCTION__ = %s __LINE__ =%d >>>>>\n", __FUNCTION__, __LINE__);
                    ui_send_event(KEY_CHANGE_PAGE, BIT(31) | PAGE_37);
                    return TRUE;
                    break;
                }
            }
        }

        ui_send_event(KEY_CHANGE_PAGE, BIT(31) | DIAL_PAGE_0);

        break;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:
        touch_action = 2;
        break;
    case ELM_EVENT_TOUCH_DOWN:
        touch_action = 1;
        break;
    case ELM_EVENT_TOUCH_U_MOVE:
        ui_send_event(KEY_CHANGE_PAGE, 1);
        break;
    case ELM_EVENT_TOUCH_D_MOVE:
        ui_send_event(KEY_CHANGE_PAGE, 0);
        break;
    default:
        break;
    }

    return false;
}


REGISTER_UI_EVENT_HANDLER(WATCH_VLIST)
.onchange = WATCH_VERTLIST_onchange,
 .onkey = NULL,
  .ontouch = WATCH_VERTLIST_ontouch,
};

typedef struct viewfile {
    RESFILE *file;
    struct flash_file_info info;
} VIEWFILE;

static int DIAL_PREVIEW_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_pic *pic = (struct ui_pic *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    /* static FILE *view_file = NULL; */
    /* static FILE *view1_file = NULL; */
    /* static FILE *view2_file = NULL; */
    /* static FILE *view3_file = NULL; */
    /* static FILE *view4_file = NULL; */
    /* static FILE *view5_file = NULL; */
    static VIEWFILE view_file[MAX_GRID_ITEM] = {0};
    static u32 open_flag = 0;
    int sel_item;
    char tmp_name[100];
    char *sty_suffix = ".sty";
    char *view_suffix = ".view";
    char *watch_item;
    u32 tmp_strlen;
    u32 sty_strlen;

    switch (event) {
    case ON_CHANGE_INIT:
        int items_num = 0;
        if (open_flag) {
            break;
        }
        items_num = watch_get_items_num();
        items_num = (items_num >= MAX_GRID_ITEM) ? MAX_GRID_ITEM : items_num;
        sty_strlen = strlen(sty_suffix);
        for (sel_item = 0; sel_item < items_num; sel_item++) {
            watch_item = watch_get_item(sel_item);
            if (watch_item == NULL) {
                printf("prew get item err %d\n", sel_item);
                return FALSE;
            }

            tmp_strlen = strlen(watch_item);
            strcpy(tmp_name, watch_item);
            strcpy(&tmp_name[tmp_strlen - sty_strlen], view_suffix);
            tmp_name[tmp_strlen - sty_strlen + strlen(view_suffix)] = '\0';
            printf("prew name %s\n", tmp_name);
            view_file[sel_item].file = res_fopen(tmp_name, "r");
            if (!view_file[sel_item].file) {
                printf("open_prewfile fail %s\n", tmp_name);
                return FALSE;
            }
            if (ui_res_flash_info_get(&view_file[sel_item].info, tmp_name, "res")) {
                printf("get_prewfile tab fail %s\n", tmp_name);
                return false;
            }
            printf("prew out\n");

        }
        open_flag = 1;

        break;
    case ON_CHANGE_SHOW:
        if (pic->elm.id == DIAL0_PREVIEW) {
            sel_item = 0;

            /* if (!view_file) { */
            /* view_file = res_fopen(RES_PATH"watch/watch.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view_file; */
        } else if (pic->elm.id == DIAL1_PREVIEW) {
            sel_item = 1;

            /* if (!view_file) { */
            /* if (!view1_file) { */
            /* view1_file = res_fopen(RES_PATH"watch1/watch1.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view1_file; */
        } else if (pic->elm.id == DIAL2_PREVIEW) {
            sel_item = 2;

            /* if (!view_file) { */
            /* if (!view2_file) { */
            /* view2_file = res_fopen(RES_PATH"watch2/watch2.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view2_file; */
        } else if (pic->elm.id == DIAL3_PREVIEW) {
            sel_item = 3;

            /* if (!view_file) { */
            /* if (!view3_file) { */
            /* view3_file = res_fopen(RES_PATH"watch3/watch3.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view3_file; */
        } else if (pic->elm.id == DIAL4_PREVIEW) {
            sel_item = 4;

            /* if (!view_file) { */
            /* if (!view4_file) { */
            /* view4_file = res_fopen(RES_PATH"watch4/watch4.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view4_file; */
        } else if (pic->elm.id == DIAL5_PREVIEW) {
            sel_item = 5;

            /* if (!view_file) { */
            /* if (!view5_file) { */
            /* view5_file = res_fopen(RES_PATH"watch5/watch5.view", "r"); */
            /* } */
            /* pic->elm.css.background_image = 1; */
            /* dc->preview.file = view5_file; */
        } else {
            printf("select preview err0 %x\n", pic->elm.id);
            return FALSE;
        }

        if ((sel_item >= watch_get_items_num()) || (view_file[sel_item].file == NULL)) {
            printf("select preview err1 %x, %d\n", pic->elm.id, sel_item);
            return FALSE;
        }
        pic->elm.css.background_image = 1;
        dc->preview.file = view_file[sel_item].file;
        dc->preview.file_info = &view_file[sel_item].info;
        dc->preview.id = 1;
        dc->preview.page = 0;
        break;
    case ON_CHANGE_RELEASE:

        for (sel_item = 0; sel_item < MAX_GRID_ITEM; sel_item++) {
            if (view_file[sel_item].file) {
                res_fclose(view_file[sel_item].file);
                ui_res_flash_info_free(&view_file[sel_item].info, "res");
                view_file[sel_item].file = NULL;
            }
        }
        open_flag = 0;

        break;
    }

    return 0;
}

REGISTER_UI_EVENT_HANDLER(DIAL0_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL1_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL2_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL3_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL4_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
REGISTER_UI_EVENT_HANDLER(DIAL5_PREVIEW)
.onchange = DIAL_PREVIEW_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


static int watch_bgp_button_ontouch(void *ctr, struct element_touch_event *e)
{
    struct button *button = (struct button *)ctr;

    /* printf("__FUNCTION__ = %s\n", __FUNCTION__); */
    switch (e->event) {
    case ELM_EVENT_TOUCH_DOWN:
        break;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:

        break;
    case ELM_EVENT_TOUCH_UP:
        switch (button->elm.id) {
        case DIAL0_BUTTON:
            cur_grid_watch = 0;
            break;
        case DIAL1_BUTTON:
            cur_grid_watch = 1;
            break;
        case DIAL2_BUTTON:
            cur_grid_watch = 2;
            break;
        case DIAL3_BUTTON:
            cur_grid_watch = 3;
            break;
        case DIAL4_BUTTON:
            cur_grid_watch = 4;
            break;
        case DIAL5_BUTTON:
            cur_grid_watch = 5;
            break;
        default:
            return false;
        }
        ui_send_event(KEY_CHANGE_PAGE, BIT(31) | PAGE_31);
        break;
    default:
        break;
    }
    return false;
}
REGISTER_UI_EVENT_HANDLER(DIAL0_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL1_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL2_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL3_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL4_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};
REGISTER_UI_EVENT_HANDLER(DIAL5_BUTTON)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = watch_bgp_button_ontouch,
};








static int NewLayout21_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_slider *slider = (struct ui_slider *)_ctrl;
    int i;

    switch (event) {
    case ON_CHANGE_INIT:
        ui_slider_set_persent(slider, 50);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

/* REGISTER_UI_EVENT_HANDLER(NEWLAYOUT_21) */
/* .onchange = NewLayout21_onchange, */
/* .onkey = NULL, */
/* .ontouch = NULL, */
/* }; */


static int startlight_action_page_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct window *window = (struct window *)ctr;
    /* printf("enter startlight action_page = %s id =%x \n", __FUNCTION__, window->elm.id); */

    switch (e) {
    case ON_CHANGE_INIT:
        /* key_ui_takeover(1); */
        break;
    case ON_CHANGE_RELEASE:
        /* key_ui_takeover(0); */
        break;
    default:
        return false;
    }
    return false;
}


static int startlight_action_page_onkey(void *ctr, struct element_key_event *e)
{
    switch (e->value) {
    case KEY_OK:
        printf("skey_ok\n");
        ui_hide_curr_main();
        ui_show_main(PAGE_17);
        break;
    case KEY_DOWN:
        break;
    case KEY_UP:
        break;
    default:
        return false;
    }
    return false;
}

REGISTER_UI_EVENT_HANDLER(PAGE_18)
.onchange = startlight_action_page_onchange,
 .onkey = startlight_action_page_onkey,
  .ontouch = NULL,
};


static u32 icon_tstatus = 0;
static int startlight_page_ontouch(void *_layout, struct element_touch_event *e)
{
    struct layout *layout = (struct layout *)_layout;
    /* static u8 flag = 0; */

    switch (e->event) {

    case ELM_EVENT_TOUCH_UP:
        /* printf("stouch up\n"); */
        /* if (flag == 1) { */
        /* ui_hide_curr_main(); */
        /* ui_show_main(PAGE_18); */
        /* } */
        /* flag = 0; */
        break;
    case ELM_EVENT_TOUCH_HOLD:
        /* printf("stouch hold\n"); */
        break;
    case ELM_EVENT_TOUCH_MOVE:
        /* printf("stouch move\n"); */
        /* flag = 2; */
        break;
    case ELM_EVENT_TOUCH_DOWN:
        printf("stouch down\n");
        /* flag = 1; */
        icon_tstatus = 1;
        break;
    /* return true; */
    default:
        break;
    }

    return false;
}


REGISTER_UI_EVENT_HANDLER(BASEFORM_296)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};

REGISTER_UI_EVENT_HANDLER(BASEFORM_297)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_298)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_299)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_300)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_301)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_302)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_303)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_304)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_305)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_306)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_307)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_308)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_309)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_310)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_311)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_312)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_313)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};
REGISTER_UI_EVENT_HANDLER(BASEFORM_314)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = startlight_page_ontouch,
};



struct icon_list {
    struct list_head entry;
    int index;
    struct element *elm;

    int left;
    int top;
    int right;
    int bottom;

    int css_left;
    int css_top;
    int css_width;
    int css_height;

    int width;
    int height;
    int cx;
    int cy;
    int size;

    struct icon_list *icon_left_top;
    struct icon_list *icon_right_top;
    struct icon_list *icon_left;
    struct icon_list *icon_right;
    struct icon_list *icon_left_bottom;
    struct icon_list *icon_right_bottom;

};

struct scene_info {
    u32 saved;

    //layout info
    int css_left;
    int css_top;
    int css_width;
    int css_height;

    //icon_info
    int center_index;
};


struct icon_size_info {
    u16 icon_w;
    u16 icon_h;
};

struct variable_info {
    u16 init;

    //屏幕的宽和高
    u16 lcd_w;
    u16 lcd_h;

    //两点间距离的经验值，用于判断中心图标和某个图标间的距离属于哪个级别，
    //从而显示哪张尺寸的图片，这个需要调试来获取！！！
    u16 ref_distance;

    //图标的图片数和图标图片的实际宽高，用于分多级来显示
    //目前是4张图片每个图标, 每个图标尺寸一样的
    u16 icon_level;
    struct icon_size_info *ics;
    struct icon_list *icon_core;

};


LIST_HEAD(icon_root);
#define abs(x)  ((x)>0?(x):-(x) )
#define EFFECT_DEBUG 0

static struct scene_info slinfo = {0};
static struct variable_info svi = {0};

static int startlight_svi_init()
{
    if (svi.init) {
        return 0;
    }

    svi.lcd_w = 454;
    svi.lcd_h = 454;

    svi.ref_distance = 3500 * 4;

    svi.icon_level = 5;
    svi.ics = malloc(svi.icon_level * sizeof(struct icon_size_info));
    if (svi.ics == NULL) {
        printf("err malloc ics \n");
        return -1;
    }

    svi.ics[0].icon_w = 45 * 2;
    svi.ics[0].icon_h = 45 * 2;

    svi.ics[1].icon_w = 41 * 2;
    svi.ics[1].icon_h = 41 * 2;

    svi.ics[2].icon_w = 39 * 2;
    svi.ics[2].icon_h = 39 * 2;

    svi.ics[3].icon_w = 22 * 2;
    svi.ics[3].icon_h = 22 * 2;

    svi.ics[4].icon_w = 16 * 2;
    svi.ics[4].icon_h = 16 * 2;
    svi.init = 1;

    return 0;
}



static int startlight_scene_save(struct layout *layout, struct list_head *root)
{
    struct icon_list *icon_p;

    slinfo.saved = 0;

    list_for_each_entry(icon_p, root, entry) {
        if (icon_p->size == 0) {
            slinfo.center_index = icon_p->index;
            slinfo.saved = 1;
        }
    }

    if (slinfo.saved == 0) {
        printf("scene_info save fail\n");
        return -1;
    }
    slinfo.css_left = layout->elm.css.left;
    slinfo.css_top = layout->elm.css.top;
    slinfo.css_width = layout->elm.css.width;
    slinfo.css_height = layout->elm.css.height;

    return 0;
}

static int startlight_scene_recover(struct layout *layout, struct list_head *root)
{
    struct icon_list *icon_p;

    if (slinfo.saved == 0) {
        return -1;
    }

    list_for_each_entry(icon_p, root, entry) {
        if (icon_p->index == slinfo.center_index) {
            icon_p->size = 0;
        }
    }

    layout->elm.css.left = slinfo.css_left;
    layout->elm.css.top = slinfo.css_top;
    layout->elm.css.width = slinfo.css_width;
    layout->elm.css.height = slinfo.css_height;

    slinfo.saved = 0;
    return 0;
}


static int icon_is_limit(struct list_head *root)
{
    struct icon_list *icon_p;
    struct rect rect;
    struct element elm;

    list_for_each_entry(icon_p, root, entry) {

        if (icon_p->size == 0) {
            memcpy(&elm, icon_p->elm, sizeof(struct element));

            elm.css.left = icon_p->css_left;
            elm.css.top = icon_p->css_top;
            elm.css.width = icon_p->css_width;
            elm.css.height = icon_p->css_height;

            ui_core_get_element_abs_rect(&elm, &rect);
            if ((rect.left < 60) ||
                ((rect.left + rect.width) > (svi.lcd_w - 60)) ||
                (rect.top < 60) ||
                ((rect.top + rect.height) > (svi.lcd_h - 60))) {
                return 1;
            }
        }
    }


    return 0;
}


static int icon_step = 0;
/* static float ratio_tab[5] = {0.4, 0.5, 0.7, 0.9, 1}; */
/* static float ratio_tab[5] = {0.4, 0.5, 1, 1, 1}; */
static float ratio_tab[5] = {0.4, 0.5, 0.86, 0.91, 1};

static int16_t fast_atan2(int x, int y)
{
    unsigned char negflag;
    unsigned char tempdegree;
    unsigned char comp;
    unsigned int degree;
    unsigned int ux;
    unsigned int uy;

    negflag = 0;
    if (x < 0) {
        negflag += 0x01;
        x = (0 - x);
    }
    ux = x;
    if (y < 0) {
        negflag += 0x02;
        y = (0 - y);
    }
    uy = y;

    if (ux > uy) {
        degree = (uy * 45) / ux;
        negflag += 0x10;
    } else {
        degree = (ux * 45) / uy;
    }

    comp = 0;
    tempdegree = degree;
    if (tempdegree > 22) {
        if (tempdegree <= 44) {
            comp++;
        }
        if (tempdegree <= 41) {
            comp++;
        }
        if (tempdegree <= 37) {
            comp++;
        }
        if (tempdegree <= 32) {
            comp++;
        }
    } else {
        if (tempdegree >= 2) {
            comp++;
        }
        if (tempdegree >= 6) {
            comp++;
        }
        if (tempdegree >= 10) {
            comp++;
        }
        if (tempdegree >= 15) {
            comp++;
        }
    }
    degree += comp;

    if (negflag & 0x10) {
        degree = (90 - degree);
    }

    if (negflag & 0x02) {
        if (negflag & 0x01) {
            degree = (180 + degree);
        } else {
            degree = (180 - degree);
        }
    } else {
        if (negflag & 0x01) {
            degree = (360 - degree);
        }
    }
    return degree;
}
static inline int get_angle(int angx, int angy)
{
    return (int)(fast_atan2(angy, angx));
}



int icon_change(struct list_head *root, struct element *elm, int draw)
{
    /* struct element *p; */
    struct icon_list *icon_p = NULL;
    struct icon_list *n = NULL;
    struct rect rect;

    int center_x;
    int center_y;
    int center_change;
    int center_index;

    int s_icon, p_icon;
    struct element elm_tmp;
    struct element *elm_p;
    struct element *layout_elm = elm;
    int cx, cy;
    int xoffset, yoffset;
    float ratio;
    int limit = svi.icon_level - 1;
    struct icon_list *icon_core = svi.icon_core;
    u32 radius = svi.lcd_w / 2;
    int r0 = 0;
    float r1;
    float d0;
    int disx, disy;
    float tx, ty;
    int angle;
    struct rect layout_rect;
    int icon_core_ori_cx, icon_core_ori_cy;
    struct element elm_mix;

    ui_core_get_element_abs_rect(layout_elm, &layout_rect);
    /* printf("\n\nlay %d, %d, %d, %d\n\n", layout_rect.left, layout_rect.top, layout_rect.width, layout_rect.height); */

    center_index = -1;
    list_for_each_entry(icon_p, root, entry) {
        if (icon_p->size) {
            icon_p->size = -1;
        } else {
            icon_p->size = -1;
            center_index = icon_p->index;
        }
    }

    center_change = false;
    list_for_each_entry(icon_p, root, entry) {
        /* struct element elm; */
        /* memcpy(&elm, icon_p->elm, sizeof(struct element)); */

        elm_tmp.parent = icon_p->elm->parent;
        elm_tmp.css.left = icon_p->css_left;
        elm_tmp.css.top = icon_p->css_top;
        elm_tmp.css.width = icon_p->css_width;
        elm_tmp.css.height = icon_p->css_height;

        ui_core_get_element_abs_rect(&elm_tmp, &rect);
        if ((rect.left < (svi.lcd_w / 2)) &&
            ((rect.left + rect.width) > (svi.lcd_w / 2)) &&
            (rect.top < (svi.lcd_h / 2)) &&
            ((rect.top + rect.height) > (svi.lcd_h / 2))) {
            /* icon_p->size = 0;  */
            center_change = true;
            break;
        }
    }

    if (!center_change) {
        if (center_index != (-1)) {
            list_for_each_entry(icon_p, root, entry) {
                if (icon_p->index == center_index) {
                    icon_p->size = 0;//记录中心图标的圆心位置 */
                    center_x = icon_p->cx;
                    center_y = icon_p->cy;
                    break;
                }
            }
        } else {
#if EFFECT_DEBUG
            printf("not find center!\n");
#endif
            if (icon_step == 0) {
                return -1;
            }
        }
    } else {
        icon_p->size = 0; //记录中心图标的圆心位置 */
        center_x = icon_p->cx;
        center_y = icon_p->cy;
        center_index = icon_p->index;
    }


    /* printf("zero index %x\n", icon_p->index); */

    list_for_each_entry(icon_p, root, entry) {

        if (icon_step != 0) {
            goto __icon_step_ctl;
        }

        int distance = abs(icon_p->cx - center_x) * abs(icon_p->cx - center_x) + abs(icon_p->cy - center_y) * abs(icon_p->cy - center_y);

        /* printf("dis %d\n", distance); */

        if (icon_p->size == -1) {
            if (distance < svi.ref_distance) {
                icon_p->size = 1;
            } else {
                icon_p->size = 2;
            }

            struct element elm;
            elm.parent = icon_p->elm->parent;
            elm.css.left = icon_p->css_left;
            elm.css.top = icon_p->css_top;
            elm.css.width = icon_p->css_width;
            elm.css.height = icon_p->css_height;
            ui_core_get_element_abs_rect(&elm, &rect);

            if (svi.lcd_w == 454) {

                r0 = rect.width / 2;
                cx = rect.left + r0;
                cy = rect.top + r0;
                disx = abs(cx - icon_core->cx);
                disy = abs(cy - icon_core->cy);
                d0 = complex_abs_float((float)disx, (float)disy) + r0;

                if (d0 > radius) {
                    xoffset = 0;
                    yoffset = 0;
                    icon_p->size = 3;

                    angle = get_angle(cx - icon_core->cx, cy - icon_core->cy);

                    /* printf("index %d, angle: %d\n", icon_p->index, angle); */
                    /* put_float(d0); */
                    /* printf("\n"); */

                    r1 = r0 - (d0 - radius) / 2.0;
                    if ((r1 <= 0) || (r1 > r0)) {
                        cx = 0;
                        cy = 0;
                        r1 = 0;
                        /* printf("exit one\n"); */
                        goto __end_caculate;
                    }
                    if (icon_step == 0) {
                        if (2 * r1 > svi.ics[2].icon_w) {
                            r1 = svi.ics[2].icon_w / 2.0;
                        }
                    }

                    tx = cos_float(angle / 180.f) * (radius - r1);
                    ty = sin_float(angle / 180.f) * (radius - r1);
                    if ((angle >= 270) || (angle <= 90)) {
                        cx = icon_core->cx + abs(tx) - r1 - 2;
                    } else {
                        cx = icon_core->cx - abs(tx) - r1 + 2;
                    }
                    if ((angle >= 0) && (angle <= 180)) {
                        cy = icon_core->cy + abs(ty) - r1 - 2;
                    } else {
                        cy = icon_core->cy - abs(ty) - r1 + 2;
                    }
                    /* printf("info: %d, %d\n", cx, cy); */
                    /* put_float(tx); */
                    /* put_float(ty); */
                    /* put_float(r1); */
                    /* printf("\n"); */

__end_caculate:
                    if (icon_step != 0) {
                        s_icon = limit;
                        if (icon_step < 0) {
                            s_icon = s_icon - icon_step;
                            s_icon = (s_icon > limit) ? limit : s_icon;
                        } else {
                            s_icon = s_icon - icon_step;
                            s_icon = (s_icon < 0) ? 0 : s_icon;
                        }
                        cx = svi.ics[s_icon].icon_w;
                        cy = svi.ics[s_icon].icon_h;
                        xoffset = 0;
                        yoffset = 0;
                        r0 = 0;
                    }

                }

            } else {

                if ((rect.left < 0) || (rect.top < 0) || ((rect.left + rect.width) > svi.lcd_w) || ((rect.top + rect.height) > svi.lcd_h)) {

                    xoffset = 0;
                    yoffset = 0;
                    icon_p->size = 3;

                    cy = 10000;
                    cx = 10000;
                    if (rect.left < 0) {
                        cx = rect.left + rect.width;
                        /* xoffset = (abs(rect.left) / 2) * 10000 / svi.lcd_w; */
                        xoffset = (abs(rect.left) / 2) * 10000 / layout_rect.width;
                        if (icon_step == 0) {
                            if (cx > svi.ics[2].icon_w) {
                                cx = svi.ics[2].icon_w;
                            }
                        }
                    }
                    if (rect.top < 0) {
                        cy = rect.top + rect.height;
                        /* yoffset = (abs(rect.top) / 2) * 10000 / svi.lcd_h; */
                        yoffset = (abs(rect.top) / 2) * 10000 / layout_rect.height;
                        if (icon_step == 0) {
                            if (cy > svi.ics[2].icon_h) {
                                cy = svi.ics[2].icon_h;
                            }
                        }
                    }
                    if ((rect.left + rect.width) > svi.lcd_w) {
                        cx = svi.lcd_w - rect.left;
                        /* xoffset = -(abs(rect.width - cx) / 2) * 10000 / svi.lcd_w; */
                        xoffset = -(abs(rect.width - cx) / 2) * 10000 / layout_rect.width;
                        if (icon_step == 0) {
                            if (cx > svi.ics[2].icon_w) {
                                cx = svi.ics[2].icon_w;
                            }
                        }
                    }
                    if ((rect.top + rect.height) > svi.lcd_h) {
                        cy = svi.lcd_h - rect.top;
                        /* yoffset = -(abs(rect.height - cy) / 2) * 10000 / svi.lcd_h; */
                        yoffset = -(abs(rect.height - cy) / 2) * 10000 / layout_rect.height;
                        if (icon_step == 0) {
                            if (cy > svi.ics[2].icon_h) {
                                cy = svi.ics[2].icon_h;
                            }
                        }
                    }

                    if ((cx != 10000) && (cy != 10000)) {
                        cx = (cx > cy) ? cy : cx;
                    } else {
                        if (cx == 10000) {
                            cx = cy;
                        } else {
                            cy = cx;
                        }
                    }

                    if (cx <= 0) {
                        xoffset = 0;
                        yoffset = 0;
                        cx = 0;
                        cy = 0;
                    }
                    if (icon_step != 0) {
                        s_icon = limit;
                        if (icon_step < 0) {
                            s_icon = s_icon - icon_step;
                            s_icon = (s_icon > limit) ? limit : s_icon;
                        } else {
                            s_icon = s_icon - icon_step;
                            s_icon = (s_icon < 0) ? 0 : s_icon;
                        }
                        cx = svi.ics[s_icon].icon_w;
                        cy = svi.ics[s_icon].icon_h;
                        xoffset = 0;
                        yoffset = 0;
                    }

                } //end style_rc

            }

        }


__icon_step_ctl:
        //test
        if (icon_step != 0) {
            if (icon_step < 0) {
                s_icon = abs(icon_step);
            } else {
                s_icon = 0;
            }
            s_icon = (s_icon > limit) ? limit : s_icon;
            s_icon = (s_icon < 0) ? 0 : s_icon;
            cx = svi.ics[s_icon].icon_w;
            cy = svi.ics[s_icon].icon_h;
            xoffset = 0;
            yoffset = 0;
            r0 = 0;
            icon_p->size = 3;
        }


        /* printf("%d, %d, %d, %d, %d, %d\n", icon_p->size, size0, size1, size2, size3, distance); */

        if (icon_p->size == 0) {
            struct element *elm = icon_p->elm;
            elm->css.left = icon_p->css_left;
            elm->css.top = icon_p->css_top;
            elm->css.width = icon_p->css_width;
            elm->css.height = icon_p->css_height;

            s_icon = 0;
            p_icon = limit;
            if (icon_step < 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon > limit) ? limit : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon < 0) ? 0 : p_icon;

                /* elm->css.width = svi.ics[s_icon].icon_w * 10000 / svi.lcd_w; */
                /* elm->css.height = svi.ics[s_icon].icon_h * 10000 / svi.lcd_h; */
                elm->css.width = svi.ics[s_icon].icon_w * 10000 / layout_rect.width;
                elm->css.height = svi.ics[s_icon].icon_h * 10000 / layout_rect.height;

            } else if (icon_step > 0) {

            } else {

            }

            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio_tab[p_icon];
            elm->css.ratio.ratio_h = ratio_tab[p_icon];
        } else if (icon_p->size == 1) {
            struct element *elm = icon_p->elm;

            s_icon = 1;
            p_icon = 3;
            if (icon_step < 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon > limit) ? limit : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon < 0) ? 0 : p_icon;

            } else if (icon_step > 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon < 0) ? 0 : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon > limit) ? limit : p_icon;
            } else {

            }

            /* elm->css.width = svi.ics[s_icon].icon_w * 10000 / svi.lcd_w; */
            /* elm->css.height = svi.ics[s_icon].icon_h * 10000 / svi.lcd_h; */
            elm->css.width = svi.ics[s_icon].icon_w * 10000 / layout_rect.width;
            elm->css.height = svi.ics[s_icon].icon_h * 10000 / layout_rect.height;

            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio_tab[p_icon];
            elm->css.ratio.ratio_h = ratio_tab[p_icon];
        } else if (icon_p->size == 2) {
            struct element *elm = icon_p->elm;

            s_icon = 2;
            p_icon = 2;
            if (icon_step < 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon > limit) ? limit : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon < 0) ? 0 : p_icon;

            } else if (icon_step > 0) {
                s_icon = s_icon - icon_step;
                s_icon = (s_icon < 0) ? 0 : s_icon;
                p_icon = p_icon + icon_step;
                p_icon = (p_icon > limit) ? limit : p_icon;
            } else {

            }
            /* elm->css.width = svi.ics[s_icon].icon_w * 10000 / svi.lcd_w; */
            /* elm->css.height = svi.ics[s_icon].icon_h * 10000 / svi.lcd_h; */
            elm->css.width = svi.ics[s_icon].icon_w * 10000 / layout_rect.width;
            elm->css.height = svi.ics[s_icon].icon_h * 10000 / layout_rect.height;

            elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2;
            elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2;

            elm->css.ratio.en = 1;
            elm->css.ratio.ratio_w = ratio_tab[p_icon];
            elm->css.ratio.ratio_h = ratio_tab[p_icon];
        } else if (icon_p->size >= 3) {
            struct element *elm = icon_p->elm;

            if ((svi.lcd_w == 454) && (r0 > 0)) {

                elm->css.width = 2 * r1 * 10000 / layout_rect.width;
                elm->css.height = 2 * r1 * 10000 / layout_rect.height;
                elm->css.left = (cx - layout_rect.left) * 10000 / layout_rect.width;
                elm->css.top = (cy - layout_rect.top) * 10000 / layout_rect.height;

                /* printf("%d, %d, %d, %d, %d, %d\n", elm->css.left, elm->css.top, rect.left, rect.top, layout_elm->css.left, layout_elm->css.top); */
                /* struct rect test_rect; */
                /* struct element test_elm; */
                /* test_elm.parent = icon_p->elm->parent; */

                /* test_elm.css.left = elm->css.left; */
                /* test_elm.css.top = elm->css.top; */
                /* test_elm.css.width = elm->css.width; */
                /* test_elm.css.height = elm->css.height; */
                /* ui_core_get_element_abs_rect(&test_elm, &test_rect); */
                /* printf("\n\ntest %d, %d, %d, %d\n\n", test_rect.left, test_rect.top, test_rect.width, test_rect.height); */

                ratio = (float)r1 / r0;
                elm->css.ratio.en = 1;
                elm->css.ratio.ratio_w = ratio;
                elm->css.ratio.ratio_h = ratio;
            } else {
                /* elm->css.width = cx * 10000 / svi.lcd_w; */
                /* elm->css.height = cy * 10000 / svi.lcd_h; */
                elm->css.width = cx * 10000 / layout_rect.width;
                elm->css.height = cy * 10000 / layout_rect.height;

                elm->css.left = icon_p->css_left + (icon_p->css_width - elm->css.width) / 2 + xoffset;
                elm->css.top = icon_p->css_top + (icon_p->css_height - elm->css.height) / 2 + yoffset;

                ratio = (float)cx / rect.width;
                elm->css.ratio.en = 1;
                elm->css.ratio.ratio_w = ratio;
                elm->css.ratio.ratio_h = ratio;

                if (icon_step != 0) {
                    elm->css.ratio.ratio_w -= 0.03;
                    elm->css.ratio.ratio_h -= 0.03;
                }

                /* printf("\nratio"); */
                /* put_float(ratio); */
                /* printf("\n"); */

                /* struct rect test_rect; */
                /* struct element test_elm; */

                /* test_elm.parent = icon_p->elm->parent; */
                /* test_elm.css.left = elm->css.left; */
                /* test_elm.css.top = elm->css.top; */
                /* test_elm.css.width = elm->css.width; */
                /* test_elm.css.height = elm->css.height; */
                /* ui_core_get_element_abs_rect(&test_elm, &test_rect); */
                /* printf("\n\ntest %d, %d, %d, %d\n\n", test_rect.left, test_rect.top, test_rect.width, test_rect.height); */




            }
        }

    }

#if 1
    struct rect cur_rect, icon_core_rect;
    int icon_core_dsize, icon_dsize;
    int icon_core_cx, icon_core_cy;

    if (icon_step != 0) {

        elm_mix.parent = icon_core->elm->parent;
        elm_mix.css.left = icon_core->css_left;
        elm_mix.css.top = icon_core->css_top;
        elm_mix.css.width = icon_core->css_width;
        elm_mix.css.height = icon_core->css_height;
        ui_core_get_element_abs_rect(&elm_mix, &rect);

        elm_mix.parent = icon_core->elm->parent;
        elm_mix.css.left = icon_core->elm->css.left;
        elm_mix.css.top = icon_core->elm->css.top;
        elm_mix.css.width = icon_core->elm->css.width;
        elm_mix.css.height = icon_core->elm->css.height;
        ui_core_get_element_abs_rect(&elm_mix, &icon_core_rect);


        icon_core_ori_cx = rect.left + rect.width / 2;
        icon_core_ori_cy = rect.top + rect.height / 2;
        icon_core_cx = icon_core_rect.left + icon_core_rect.width / 2;
        icon_core_cy = icon_core_rect.top + icon_core_rect.height / 2;
        icon_core_dsize = (rect.width - icon_core_rect.width) / 2;

        /* printf("icon_core: %d, %d, %d\n", icon_core_cx, icon_core_cy, icon_core_dsize); */

        list_for_each_entry(icon_p, root, entry) {

            if (icon_p == icon_core) {
                continue;
            }

            elm_mix.parent = icon_p->elm->parent;
            elm_mix.css.left = icon_p->css_left;
            elm_mix.css.top = icon_p->css_top;
            elm_mix.css.width = icon_p->css_width;
            elm_mix.css.height = icon_p->css_height;
            ui_core_get_element_abs_rect(&elm_mix, &rect);

            elm_mix.parent = icon_p->elm->parent;
            elm_mix.css.left = icon_p->elm->css.left;
            elm_mix.css.top = icon_p->elm->css.top;
            elm_mix.css.width = icon_p->elm->css.width;
            elm_mix.css.height = icon_p->elm->css.height;
            ui_core_get_element_abs_rect(&elm_mix, &cur_rect);

            icon_dsize = (rect.width - cur_rect.width) / 2;

            r1 = cur_rect.width / 2;
            r0 = rect.width / 2;
            cx = rect.left + r0;
            cy = rect.top + r0;
            /* disx = abs(cx - icon_core_cx); */
            /* disy = abs(cy - icon_core_cy); */
            disx = abs(cx - icon_core_ori_cx);
            disy = abs(cy - icon_core_ori_cy);
            d0 = complex_abs_float((float)disx, (float)disy);

            /* printf("info: %d, %d, %d, %d, %d", r0, cx, cy, disx, disy); */
            /* put_float(r1); */
            /* put_float(d0); */


            /* d0 = d0 - icon_dsize - icon_core_dsize; */
            d0 = d0 * (r1 / r0) + 0.5;
            angle = get_angle(cx - icon_core_ori_cx, cy - icon_core_ori_cy);

            tx = cos_float(angle / 180.f) * d0;
            ty = sin_float(angle / 180.f) * d0;


            /* put_float(tx); */
            /* put_float(ty); */

            if ((angle >= 270) || (angle <= 90)) {
                cx = icon_core_cx + abs(tx) - r1 - 1;
            } else {
                cx = icon_core_cx - abs(tx) - r1 + 1;
            }
            if ((angle >= 0) && (angle <= 180)) {
                cy = icon_core_cy + abs(ty) - r1 - 1;
            } else {
                cy = icon_core_cy - abs(ty) - r1 + 1;
            }

            /* disx = cx + r1 / 2; */
            /* disy = cy + r1 / 2; */
            /* if (disx <= icon_core_cx) { */
            /* cx -= 10;	 */
            /* } else { */
            /* cx += 10;	 */
            /* } */
            /* if (disy <= icon_core_cy) { */
            /* cy -= 10;	 */
            /* } else { */
            /* cy += 10;	 */
            /* } */

            //testcccc
            disx = abs(cx + r1 - icon_core_cx);
            disy = abs(cy + r1 - icon_core_cy);
            d0 = complex_abs_float((float)disx, (float)disy);
            /* printf("\nccc:%d, %d, %d, %d\n", icon_dsize, icon_core_dsize, disx, disy); */
            /* put_float(d0); */
            /* printf("\n"); */

            icon_p->elm->css.left = (cx - layout_rect.left) * 10000 / layout_rect.width;
            icon_p->elm->css.top = (cy - layout_rect.top) * 10000 / layout_rect.height;


        }

    }

    if (icon_step != 0) {
        list_for_each_entry(icon_p, root, entry) {
            if (icon_p->index == center_index) {
                icon_p->size = 0;//记录中心图标的圆心位置 */
                break;
            }
        }

    }
#else


    int distance_x;
    int distance_y;
    int step;
    int cur_center_y;
    int tmp_y;
    struct icon_list *left = NULL;
    struct icon_list *right = NULL;
    struct icon_list *cur_left = NULL;
    struct icon_list *cur_right = NULL;
    int center_diffx;
    int center_diffy;

    if (icon_step < 0) {
        list_for_each_entry(icon_p, root, entry) {
            if (icon_p->index == 0) {
                n = icon_p;
                break;
            }
        }
        ASSERT(n);
        step = abs(icon_step);
        step = (step > 4) ? 4 : step;
        /* distance_x = (svi.ics[0].icon_w - svi.ics[step].icon_w) * 10000 / svi.lcd_w / 2; */
        /* distance_y = (svi.ics[0].icon_h - svi.ics[step].icon_h) * 10000 / svi.lcd_h / 2; */
        /* center_diffx = (n->cx - n->icon_left->cx) * 10000 / svi.lcd_w - distance_x * 2; */
        /* center_diffy = (n->cy - n->icon_left_top->cy) * 10000 / svi.lcd_h - distance_y * 2; */


        /* distance_x = (svi.ics[0].icon_w - svi.ics[step].icon_w) * 10000 / layout_rect.width / 2; */
        /* distance_y = (svi.ics[0].icon_h - svi.ics[step].icon_h) * 10000 / layout_rect.height / 2; */
        /* center_diffx = (n->cx - n->icon_left->cx) * 10000 / layout_rect.width - distance_x * 2; */
        /* center_diffy = (n->cy - n->icon_left_top->cy) * 10000 / layout_rect.height - distance_y * 2; */

        distance_x = (svi.ics[0].icon_w - svi.ics[step].icon_w) / 10;
        distance_y = (svi.ics[0].icon_h - svi.ics[step].icon_h) / 10;
        center_diffx = ((n->cx - n->icon_left->cx) - distance_x * 11) * 10000 / layout_rect.width;
        center_diffy = ((n->cy - n->icon_left_top->cy) - distance_y * 11) * 10000 / layout_rect.height;

        left = n;
        right = n;
        cur_left = n;
        cur_right = n;
        cur_center_y = n->elm->css.top + n->elm->css.height / 2;
        do {

            left = cur_left;
            right = cur_right;
            /* printf("now %x, %x\n", left->index, right->index); */

            do {
                if (left == NULL) {
                    break;
                }
                left = left->icon_left;
                if (left == NULL) {
                    break;
                }
                elm_p = left->elm;
                elm_p->css.left = left->icon_right->elm->css.left + left->icon_right->elm->css.width / 2 - center_diffx - elm_p->css.width / 2;
                elm_p->css.top = cur_center_y - elm_p->css.height / 2;

            } while (1);
            do {
                if (right == NULL) {
                    break;
                }
                right = right->icon_right;
                if (right == NULL) {
                    break;
                }

                elm_p = right->elm;
                elm_p->css.left = right->icon_left->elm->css.left + right->icon_left->elm->css.width / 2 + center_diffx - elm_p->css.width / 2;
                elm_p->css.top = cur_center_y - elm_p->css.height / 2;

            } while (1);

            if ((cur_left == NULL) && (cur_right == NULL)) {
                break;
            }
            if (cur_left == cur_right) {
                if ((cur_left->icon_left_top == NULL) && (cur_left->icon_right_top == NULL)) {
                    break;
                }

                if (cur_left->icon_left_top) {
                    left = cur_left->icon_left_top;
                    elm_p = left->elm;
                    elm_p->css.left = left->icon_right_bottom->elm->css.left + left->icon_right_bottom->elm->css.width / 2 - center_diffx / 2 - elm_p->css.width / 2;
                    elm_p->css.top = cur_center_y - center_diffy - elm_p->css.height / 2;
                    tmp_y = elm_p->css.top + elm_p->css.height / 2;
                }
                if (cur_left->icon_right_top) {
                    right = cur_left->icon_right_top;
                    elm_p = right->elm;
                    elm_p->css.left = right->icon_left_bottom->elm->css.left + right->icon_left_bottom->elm->css.width / 2 + center_diffx / 2 - elm_p->css.width / 2;
                    elm_p->css.top = cur_center_y - center_diffy - elm_p->css.height / 2;
                    tmp_y = elm_p->css.top + elm_p->css.height / 2;
                }

                cur_right = cur_left->icon_right_top;
                cur_left = cur_left->icon_left_top;
                cur_center_y = tmp_y;
            } else {
                if (cur_left) {
                    left = cur_left->icon_right_top;
                } else {
                    left = cur_right->icon_left_top;
                }
                elm_p = left->elm;
                elm_p->css.left = elm_p->css.left;
                elm_p->css.top = cur_center_y - center_diffy - elm_p->css.height / 2;

                cur_center_y = elm_p->css.top + elm_p->css.height / 2;
                cur_left = left;
                cur_right = left;
            }
        } while (1);



        left = n;
        right = n;
        cur_left = n;
        cur_right = n;
        cur_center_y = n->elm->css.top + n->elm->css.height / 2;
        do {

            if ((cur_left == NULL) && (cur_right == NULL)) {
                break;
            }
            if (cur_left == cur_right) {
                if ((cur_left->icon_left_bottom == NULL) && (cur_left->icon_right_bottom == NULL)) {
                    break;
                }

                if (cur_left->icon_left_bottom) {
                    left = cur_left->icon_left_bottom;
                    elm_p = left->elm;
                    elm_p->css.left = left->icon_right_top->elm->css.left + left->icon_right_top->elm->css.width / 2 - center_diffx / 2 - elm_p->css.width / 2;
                    elm_p->css.top = cur_center_y + center_diffy - elm_p->css.height / 2;
                    tmp_y = elm_p->css.top + elm_p->css.height / 2;
                }
                if (cur_left->icon_right_bottom) {
                    right = cur_left->icon_right_bottom;
                    elm_p = right->elm;
                    elm_p->css.left = right->icon_left_top->elm->css.left + right->icon_left_top->elm->css.width / 2 + center_diffx / 2 - elm_p->css.width / 2;
                    elm_p->css.top = cur_center_y + center_diffy - elm_p->css.height / 2;
                    tmp_y = elm_p->css.top + elm_p->css.height / 2;
                }

                cur_right = cur_left->icon_right_bottom;
                cur_left = cur_left->icon_left_bottom;
                cur_center_y = tmp_y;
            } else {
                if (cur_left) {
                    left = cur_left->icon_right_bottom;
                } else {
                    left = cur_right->icon_left_bottom;
                }
                elm_p = left->elm;
                elm_p->css.left = elm_p->css.left;
                elm_p->css.top = cur_center_y + center_diffy - elm_p->css.height / 2;

                cur_center_y = elm_p->css.top + elm_p->css.height / 2;
                cur_left = left;
                cur_right = left;
            }



            left = cur_left;
            right = cur_right;

            do {
                if (left == NULL) {
                    break;
                }
                left = left->icon_left;
                if (left == NULL) {
                    break;
                }
                elm_p = left->elm;
                elm_p->css.left = left->icon_right->elm->css.left + left->icon_right->elm->css.width / 2 - center_diffx - elm_p->css.width / 2;
                elm_p->css.top = cur_center_y - elm_p->css.height / 2;

            } while (1);
            do {
                if (right == NULL) {
                    break;
                }
                right = right->icon_right;
                if (right == NULL) {
                    break;
                }
                elm_p = right->elm;
                elm_p->css.left = right->icon_left->elm->css.left + right->icon_left->elm->css.width / 2 + center_diffx - elm_p->css.width / 2;
                elm_p->css.top = cur_center_y - elm_p->css.height / 2;

            } while (1);


        } while (1);

    }//(icon_step < 0)
#endif

#if 0
    /*修改验证*/
    list_for_each_child_element(p, elm) {
        ui_core_get_element_abs_rect(p, &rect);

#if EFFECT_DEBUG
        printf("%4d,%4d,%4d,%4d] [%3d,%3d,%3d,%3d]\n",
               p->css.left, p->css.top, p->css.width, p->css.height,
               rect.left, rect.top, rect.width, rect.height);
#endif
    }
#endif

    if (draw) {
        ui_core_redraw(elm);
    }

    return 0;
}

static int MOVING_1_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct layout *layout = (struct layout *)_ctrl;
    struct element *p;
    struct rect rect;
    struct icon_list *icon_p;
    struct icon_list *n;
    int index;
    u32 i, j, k;

    switch (event) {
    case ON_CHANGE_INIT:

        startlight_svi_init();

        index = 0;

        list_for_each_child_element(p, &layout->elm) {
            ui_core_get_element_abs_rect(p, &rect);

            struct icon_list *icon = (struct icon_list *)zalloc(sizeof(struct icon_list));
            icon->index = index++;
            icon->size = -1;
            /* icon->id = p->id; */
            icon->elm = p;

            icon->css_left = p->css.left;
            icon->css_top = p->css.top;
            icon->css_width = p->css.width;
            icon->css_height = p->css.height;

            icon->left = rect.left;
            icon->right = rect.left + rect.width - 1;
            icon->top = rect.top;
            icon->bottom = rect.top + rect.height - 1;

            icon->width = rect.width;
            icon->height = rect.height;
            icon->cx = icon->left + rect.width / 2;
            icon->cy = icon->top + rect.height / 2;
            /* icon->radius = rect.width; */
            list_add_tail(&icon->entry, &icon_root);

            if (icon->index == 0) {
                svi.icon_core = icon;
            }

        }

        for (i = 0; i < index; i++) {
            j = 0;
            list_for_each_entry(icon_p, &icon_root, entry) {
                if ((j++) == i) {
                    break;
                }
            }

            k = 0;
            list_for_each_entry(n, &icon_root, entry) {
                /* printf("ccc %x, %x, %x, %x\n", icon_p->index, n->index, (u32)icon_p, (u32)n);     */
                if (n == icon_p) {
                    continue;
                }

                if (k >= 6) {
                    break;
                }
                if ((icon_p->cy == n->cy)
                    && (abs(icon_p->left - n->right) < icon_p->width / 2)) {
                    icon_p->icon_left = n;
                    k++;
                    continue;
                }
                if ((icon_p->cy == n->cy)
                    && (abs(icon_p->right - n->left) < icon_p->width / 2)) {
                    icon_p->icon_right = n;
                    k++;
                    continue;
                }
                if ((icon_p->cy != n->cy) && (abs(icon_p->top - n->bottom) < icon_p->height / 2)
                    && (abs(icon_p->left - n->right) < icon_p->width / 2)) {
                    icon_p->icon_left_top = n;
                    k++;
                    continue;
                }
                if ((icon_p->cy != n->cy) && (abs(icon_p->top - n->bottom) < icon_p->height / 2)
                    && (abs(icon_p->right - n->left) < icon_p->width / 2)) {
                    icon_p->icon_right_top = n;
                    k++;
                    continue;
                }
                if ((icon_p->cy != n->cy) && (abs(icon_p->bottom - n->top) < icon_p->height / 2)
                    && (abs(icon_p->left - n->right) < icon_p->width / 2)) {
                    icon_p->icon_left_bottom = n;
                    k++;
                    continue;
                }
                if ((icon_p->cy != n->cy) && (abs(icon_p->bottom - n->top) < icon_p->height / 2)
                    && (abs(icon_p->right - n->left) < icon_p->width / 2)) {
                    icon_p->icon_right_bottom = n;
                    k++;
                    continue;
                }
            }

            printf("cur icon info : %d\n", icon_p->index);
            if (icon_p->icon_left != NULL) {
                printf("icon_left : %d\n", icon_p->icon_left->index);
            }
            if (icon_p->icon_right != NULL) {
                printf("icon_right : %d\n", icon_p->icon_right->index);
            }
            if (icon_p->icon_left_top != NULL) {
                printf("icon_left_top : %d\n", icon_p->icon_left_top->index);
            }
            if (icon_p->icon_right_top != NULL) {
                printf("icon_right_top : %d\n", icon_p->icon_right_top->index);
            }
            if (icon_p->icon_left_bottom != NULL) {
                printf("icon_left_bottom : %d\n", icon_p->icon_left_bottom->index);
            }
            if (icon_p->icon_right_bottom != NULL) {
                printf("icon_right_bottom : %d\n", icon_p->icon_right_bottom->index);
            }
            printf("\n\n");
        }



        //先恢复布局坐标再调icon_change,调用顺序不能改
        startlight_scene_recover(layout, &icon_root);

        icon_change(&icon_root, &layout->elm, false);

        break;

    case ON_CHANGE_RELEASE:

        startlight_scene_save(layout, &icon_root);

        list_for_each_entry_safe(icon_p, n, &icon_root, entry) {
            struct element *elm = icon_p->elm;
            elm->css.left = icon_p->css_left;
            elm->css.top = icon_p->css_top;
            elm->css.width = icon_p->css_width;
            elm->css.height = icon_p->css_height;
            list_del(&icon_p->entry);
            free(icon_p);
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

static int MOVING_1_ontouch(void *ctrl, struct element_touch_event *e)
{
    struct layout *layout = (struct layout *)ctrl;
    struct element *p;
    struct rect rect;
    static struct position pos = {0};
    int diff_x, diff_y;
    static struct rect orig = {0};
    struct icon_list *icon_p;
    /* struct icon_list *n; */
    /* static u32 need_recover = 0; */

    switch (e->event) {

    case ELM_EVENT_TOUCH_DOWN:
        /* printf("TOUCH DOWN:(%d,%d)\n",e->pos.x,e->pos.y); */
        pos.x = e->pos.x;
        pos.y = e->pos.y;

        icon_change(&icon_root, &layout->elm, false);
        ui_core_redraw(layout->elm.parent);

        orig.left = layout->elm.css.left;
        orig.top = layout->elm.css.top;
        orig.width = layout->elm.css.width;
        orig.height = layout->elm.css.height;
        break;

    case ELM_EVENT_TOUCH_UP:

        printf("touch up moving\n");

        if (icon_tstatus == 1) {
            /* ui_hide_curr_main(); */
            /* ui_show_main(PAGE_18); */
        }

        icon_tstatus = 0;


        /* if (need_recover) { */
        /* startlight_scene_recover(layout, &icon_root); */
        /* icon_change(&icon_root, &layout->elm, false); */
        /* ui_core_redraw(layout->elm.parent); */
        /* need_recover = 0; */
        /* } */
        break;

    case ELM_EVENT_TOUCH_MOVE:

        ui_io_set(IO_FRAME, HIGH);
        /* printf("(%d, %d) ", e->pos.x, e->pos.y); */

        diff_x = e->pos.x - pos.x;
        diff_y = e->pos.y - pos.y;
        /* icon_change(&icon_root, &layout->elm, true); */

        layout->elm.css.left = orig.left;
        layout->elm.css.top = orig.top;
        layout->elm.css.width = orig.width;
        layout->elm.css.height = orig.height;
        ui_core_get_element_abs_rect(&layout->elm, &rect);

        rect.left += diff_x;
        rect.top += diff_y;

        layout->elm.css.left = rect.left * 10000 / svi.lcd_w;
        layout->elm.css.top = rect.top * 10000 / svi.lcd_h;

        icon_change(&icon_root, &layout->elm, false);

        ui_core_redraw(layout->elm.parent);

        ui_io_set(IO_FRAME, LOW);

        /* if ((need_recover == 0) && (icon_is_limit(&icon_root) == 1)) { */
        /* startlight_scene_save(layout, &icon_root); */
        /* need_recover = 1; */
        /* } */

        icon_tstatus = 2;
        break;

    default:
        break;
    }
    return true;
}

#if 1
static int test_page_onkey(void *ctr, struct element_key_event *e)
{
    struct layout *layout = (struct layout *)ctr;
    int limit = svi.icon_level - 1;

    switch (e->value) {
    case KEY_OK:
        printf("skey_ok\n");
        break;
    /* case KEY_UI_DOWN: */
    case KEY_UI_MINUS:

        icon_step--;
        if (icon_step < -limit) {
            icon_step = -limit;
        }
        printf("skey_down %d\n", icon_step);

        icon_change(&icon_root, &layout->elm, false);
        ui_core_redraw(layout->elm.parent);
        printf("skey_down out\n");
        break;
    /* case KEY_UI_UP: */
    case KEY_UI_PLUS:
        icon_step++;
        if (icon_step > 1) {
            icon_step = 1;
        }
        printf("skey_up %d\n", icon_step);

        icon_change(&icon_root, &layout->elm, false);
        ui_core_redraw(layout->elm.parent);
        printf("skey_up out\n");
        break;
    default:
        return false;
    }
    return false;
}
#endif

REGISTER_UI_EVENT_HANDLER(MOVING_1)
.onchange = MOVING_1_onchange,
 /* .onkey = NULL,//test_page_onkey, */
 .onkey = test_page_onkey,
  .ontouch = MOVING_1_ontouch,
};

#if defined(TCFG_UI_ENABLE_DEMO) && TCFG_UI_ENABLE_DEMO

const u8 icon_48x49_rgb565[4704] = {//format:r5g3 g3b5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0x20, 0x60, 0x28, 0x81,
    0x28, 0x81, 0x20, 0x60, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x40, 0xE1, 0x81, 0xC3, 0xB2, 0x65, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0xB2, 0x65, 0x81, 0xC3, 0x40, 0xE1, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xA1, 0x9A, 0x04,
    0xE3, 0x06, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE3, 0x06,
    0x9A, 0x04, 0x30, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xC1, 0xB2, 0x64, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xB2, 0x64, 0x38, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x40, 0xA2, 0x04, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xA2, 0x04, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x40, 0xE1, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x40, 0xE1, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x79, 0x83, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x79, 0x83,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91, 0xE3,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0x91, 0xE4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x89, 0xE3, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0x89, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x71, 0x83, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0x71, 0x83, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xC1, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xCA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA,
    0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0xEA, 0xF3, 0x67, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x40, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0xDA, 0xC5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xF3, 0xC9, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xC5, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x91, 0xE3, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x91, 0xE3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x28, 0x81, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x28, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xA2, 0x24, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xA2, 0x24, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x60, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFE, 0x15, 0xFD, 0xB3,
    0xFD, 0xD4, 0xFE, 0x98, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x20, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x79, 0x83, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xFF, 0xFE, 0x15, 0xF4, 0x4C, 0xF5, 0x31, 0xFE, 0x36, 0xFE, 0x98,
    0xFE, 0x77, 0xFD, 0xB3, 0xF4, 0x8D, 0xF5, 0x10, 0xFF, 0x9D, 0xFE, 0x15, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x79, 0xA3, 0x00, 0x00,
    0x00, 0x00, 0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xF4, 0x6C, 0xF3, 0x68, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xF4, 0xAE, 0xFE, 0x36, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3B, 0xF4, 0xCF, 0xF4, 0x4C, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xEA, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5, 0x00, 0x00,
    0x20, 0x80, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xF4, 0xFF, 0x3B, 0xF5, 0x10, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x0B, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xAE, 0xFF, 0xFF, 0xFD, 0xB3,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x20, 0x80,
    0x61, 0x42, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xB4, 0xFF, 0x9E, 0xFF, 0x5C, 0xF4, 0xCF, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x51, 0xF4, 0x0B,
    0xF4, 0x2B, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xDE, 0xFF, 0xFF, 0xFD, 0x92,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x61, 0x42,
    0x91, 0xE4, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xA9, 0xFD, 0xF5, 0xFF, 0xDF, 0xFF, 0x3B, 0xF4, 0x8E, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3,
    0xFE, 0xFA, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x0B, 0xFF, 0xBE, 0xFF, 0xFF, 0xFD, 0xF5, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x91, 0xE4,
    0xBA, 0x64, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x68, 0xFD, 0x72, 0xFF, 0xBE, 0xFF, 0x7C, 0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x6D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA,
    0xF5, 0x10, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x77,
    0xF3, 0xA9, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xBA, 0x64,
    0xD2, 0xC5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF5, 0x31, 0xFF, 0x5C, 0xFF, 0x9D, 0xF5, 0x51, 0xF3, 0x88, 0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x36,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xF3, 0x68,
    0xF3, 0xCA, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF3, 0x68, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF5, 0x31, 0xFF, 0xFF, 0xFF, 0xDF, 0xF4, 0x8D,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xD2, 0xC5,
    0xE3, 0x06, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0x5C, 0xF4, 0x2B, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xF3, 0x68, 0xF3, 0xCA,
    0xFF, 0x7D, 0xFF, 0xFF, 0xFE, 0x98, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF4, 0x8D, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x68, 0xFF, 0x9D, 0xFF, 0xFF, 0xFE, 0xB9,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE3, 0x06,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF4, 0x6C, 0xFE, 0xD9, 0xFF, 0xDE, 0xFE, 0x57, 0xF3, 0xEA, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xF3, 0x68, 0xF3, 0xCA, 0xFF, 0x7D,
    0xFF, 0xFF, 0xFD, 0x72, 0xF3, 0x26, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x47, 0xFE, 0xB9, 0xFF, 0xFF, 0xFF, 0x5C, 0xF3, 0x88,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x47, 0xF5, 0x10, 0xFF, 0xBE, 0xFF, 0x9D, 0xFD, 0x51, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x88, 0xF3, 0xCA, 0xFF, 0x7C, 0xFF, 0xFF,
    0xFD, 0x72, 0xF3, 0x26, 0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xFD, 0x51, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0x4C, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26,
    0xE2, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF4, 0x6C, 0xFE, 0xD9, 0xFF, 0xDE, 0xFE, 0x57, 0xF3, 0xEA, 0xF3, 0x26, 0xF3, 0x26, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x98, 0xFF, 0x7D, 0xFF, 0xFF, 0xFD, 0x72,
    0xF3, 0x26, 0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF4, 0x8D, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x47, 0xFE, 0xD9, 0xFF, 0xFF, 0xFF, 0x5C, 0xF3, 0x88,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE2, 0xE6,
    0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0x5C, 0xF4, 0x2B, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x56,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xD4, 0xF3, 0x26,
    0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xF3, 0x88, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x68, 0xFF, 0x9D, 0xFF, 0xFF, 0xFE, 0xB9,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5,
    0xAA, 0x44, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF5, 0x31, 0xFF, 0x5C, 0xFF, 0x9D, 0xF5, 0x51, 0xF3, 0x88, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x8D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x16, 0xFD, 0x72,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x78,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF5, 0x31, 0xFF, 0xFF, 0xFF, 0xDF, 0xF4, 0x8D,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xAA, 0x24,
    0x81, 0xA3, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x68, 0xFD, 0x72, 0xFF, 0xBE, 0xFF, 0x7C, 0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFE, 0xD9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10,
    0xFE, 0x98, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x81, 0xA3,
    0x49, 0x02, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xA9, 0xFD, 0xF5, 0xFF, 0xDF, 0xFF, 0x3B, 0xF4, 0x8E, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xF4, 0xCF,
    0xF5, 0x10, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x0B, 0xFF, 0xBE, 0xFF, 0xFF, 0xFD, 0xF5, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x49, 0x02,
    0x08, 0x20, 0xEB, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xB4, 0xFF, 0x9E, 0xFF, 0x5C, 0xF4, 0xCF, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x2B, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xDE, 0xFF, 0xFF, 0xFD, 0x92,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xEB, 0x26, 0x08, 0x20,
    0x00, 0x00, 0xB2, 0x44, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xFD, 0xF4, 0xFF, 0x3B, 0xF5, 0x10, 0xF3, 0x47, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xF4, 0xCF, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xF4, 0xF0, 0xF4, 0x6D, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF4, 0xAE, 0xFF, 0xFF, 0xFD, 0xB3,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xB2, 0x44, 0x00, 0x00,
    0x00, 0x00, 0x59, 0x22, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0xC9, 0xF4, 0x6C, 0xF3, 0x68, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF4, 0x4C, 0xFF, 0xFF, 0xFE, 0x15, 0xF4, 0x6D, 0xFD, 0x72, 0xFE, 0x57, 0xFE, 0xB9,
    0xFE, 0x98, 0xFD, 0xD4, 0xF4, 0xAE, 0xF5, 0x31, 0xFF, 0x9D, 0xFE, 0x15, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xEA, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x59, 0x22, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x00, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1A, 0xFE, 0x15, 0xFD, 0xB3,
    0xFD, 0xD4, 0xFE, 0x98, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x71, 0x83, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x71, 0x83, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x20, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x08, 0x20, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x22, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x59, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x44, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9D, 0xF3, 0xA9, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xAA, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x20, 0xD2, 0xC5, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0xC9, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA,
    0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0xCA, 0xF3, 0x67, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xD2, 0xC5, 0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0xA1, 0xE3, 0x06, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xE3, 0x06, 0x30, 0xA1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xE1, 0xEB, 0x06,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xEB, 0x06, 0x40, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xC1,
    0xE3, 0x06, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xE2, 0xE6,
    0x38, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x81, 0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5, 0x28, 0x81,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x20, 0x9A, 0x04, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0x9A, 0x04, 0x08, 0x20, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xE2, 0xCA, 0xA5, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xCA, 0xA5, 0x48, 0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x59, 0x42, 0xCA, 0xA5, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xCA, 0xA5, 0x59, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xC1,
    0x91, 0xE4, 0xDA, 0xE6, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26,
    0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xF3, 0x26, 0xDA, 0xE6, 0x91, 0xE4,
    0x38, 0xC1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x28, 0x81, 0x59, 0x22, 0x81, 0xA3, 0xA2, 0x24, 0xBA, 0x65, 0xC2, 0x85,
    0xC2, 0x85, 0xBA, 0x65, 0xA2, 0x24, 0x81, 0xA3, 0x59, 0x22, 0x28, 0x81, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

const u8 icon_48x49_argb8565[7056] = {//format:a8 r5g3 g3b5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D,
    0xEB, 0x07, 0x22, 0xF3, 0x46, 0x2B, 0xF3, 0x26, 0x2B, 0xF3, 0x26, 0x22, 0xF3, 0x46, 0x0D, 0xFB,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x08, 0xFB, 0x08, 0x4A, 0xF3, 0x26, 0x8B, 0xF3, 0x26, 0xC1, 0xF3, 0x26, 0xEC, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xEC, 0xF3, 0x26, 0xC1, 0xF3, 0x26, 0x8B, 0xF3, 0x26, 0x4A, 0xF3, 0x26, 0x08, 0xFB, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xF3, 0x26, 0xA0, 0xF3, 0x26,
    0xF2, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF2, 0xF3, 0x26,
    0xA0, 0xF3, 0x26, 0x38, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3E, 0xF3, 0x26, 0xBD, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xBD, 0xF3, 0x26, 0x3E, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0xF3,
    0x46, 0xAB, 0xF3, 0x26, 0xFE, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFE, 0xF3, 0x26, 0xAB, 0xF3, 0x26, 0x19,
    0xEB, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0xF3, 0x26, 0xEB, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEB,
    0xF3, 0x26, 0x48, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xF3, 0x26, 0xFD, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFD, 0xF3, 0x26, 0x80, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x02, 0xFC, 0x00, 0x99, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x9A, 0xF3, 0x26, 0x01, 0xF8, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x97, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x96, 0xF3, 0x26, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x78, 0xF3,
    0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xF3, 0x26, 0xFC,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xEA, 0xFF,
    0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3,
    0xEA, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x67, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFC, 0xF3,
    0x26, 0x44, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xEB, 0x06, 0xE5, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xBE, 0xFF, 0xF3, 0xC9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xE5, 0xF3, 0x26, 0x10, 0xEB, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0x98, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0xF3, 0x46, 0xFC, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFC, 0xF3, 0x26, 0x2C, 0xF3, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xAA, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x21, 0xF3, 0x26, 0xFC, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFE, 0xFA, 0xFF, 0xFE, 0x15, 0xFF, 0xFD, 0xB3, 0xFF, 0xFD, 0xD4, 0xFF, 0xFE, 0x98, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFC, 0xF3, 0x26, 0x22, 0xF3, 0x06, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x83, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x15, 0xFF, 0xF4, 0x4C, 0xFF,
    0xF5, 0x31, 0xFF, 0xFE, 0x36, 0xFF, 0xFE, 0x98, 0xFF, 0xFE, 0x77, 0xFF, 0xFD, 0xB3, 0xFF, 0xF4,
    0x8D, 0xFF, 0xF5, 0x10, 0xFF, 0xFF, 0x9D, 0xFF, 0xFE, 0x15, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x83, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xDA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xC9, 0xFF, 0xF4, 0x6C, 0xFF, 0xF3,
    0x68, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xF4, 0xAE, 0xFF, 0xFE, 0x36, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x3B, 0xFF, 0xF4, 0xCF, 0xFF, 0xF4, 0x4C, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xDB, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x27, 0xF3, 0x46, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xF4, 0xFF, 0xFF, 0x3B, 0xFF, 0xF5,
    0x10, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x0B, 0xFF, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF4, 0xAE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x27, 0xF3, 0x46,
    0x66, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xB4, 0xFF, 0xFF, 0x9E, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0xCF, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0xC9, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x51, 0xFF, 0xF4, 0x0B,
    0xFF, 0xF4, 0x2B, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF,
    0xFF, 0xDE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x66, 0xF3, 0x26,
    0x9A, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFD, 0xF5, 0xFF, 0xFF,
    0xDF, 0xFF, 0xFF, 0x3B, 0xFF, 0xF4, 0x8E, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xFE, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3,
    0xFF, 0xFE, 0xFA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x0B, 0xFF, 0xFF, 0xBE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFD, 0xF5, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x9A, 0xF3, 0x26,
    0xC3, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF, 0xFD, 0x72, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0x7C, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x6D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFF, 0xF5, 0x10, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x77,
    0xFF, 0xF3, 0xA9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xC3, 0xF3, 0x26,
    0xE1, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF,
    0x9D, 0xFF, 0xF5, 0x51, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x36,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFF, 0xF3, 0x68, 0xFF, 0xF3, 0xCA, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF3, 0x68, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xE1, 0xF3, 0x26,
    0xF4, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0x2B, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFE, 0xFA, 0xFF, 0xF3, 0x68, 0xFF, 0xF3, 0xCA, 0xFF, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
    0x98, 0xFF, 0xFF, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF,
    0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xB9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF4, 0xF3, 0x26,
    0xFD, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x6C, 0xFF, 0xFE, 0xD9, 0xFF, 0xFF,
    0xDE, 0xFF, 0xFE, 0x57, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFA, 0xFF,
    0xF3, 0x68, 0xFF, 0xF3, 0xCA, 0xFF, 0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3,
    0x26, 0xFF, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x47, 0xFF, 0xFE, 0xB9, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFD, 0xF3, 0x26,
    0xFA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x47, 0xFF, 0xF5, 0x10, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0x9D, 0xFF, 0xFD, 0x51, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x88, 0xFF,
    0xF3, 0xCA, 0xFF, 0xFF, 0x7C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF5,
    0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0x51, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF4, 0x4C, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFA, 0xF3, 0x26,
    0xEE, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x6C, 0xFF, 0xFE, 0xD9, 0xFF, 0xFF,
    0xDE, 0xFF, 0xFE, 0x57, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0x5C,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x98, 0xFF,
    0xFF, 0x7D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x10, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x47, 0xFF, 0xFE, 0xD9, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEE, 0xF3, 0x26,
    0xD7, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x98, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0x2B, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x56,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFD, 0xD4, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF,
    0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xB9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xD7, 0xF3, 0x26,
    0xB5, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF, 0xFF, 0x5C, 0xFF, 0xFF,
    0x9D, 0xFF, 0xF5, 0x51, 0xFF, 0xF3, 0x88, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x8D,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFE, 0x16, 0xFF, 0xFD, 0x72, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x78,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF5, 0x31, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0xFF, 0xF4, 0x8D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xB5, 0xF3, 0x26,
    0x88, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x68, 0xFF, 0xFD, 0x72, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0x7C, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xFE, 0xD9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x10,
    0xFF, 0xFE, 0x98, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x88, 0xF3, 0x26,
    0x50, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFD, 0xF5, 0xFF, 0xFF,
    0xDF, 0xFF, 0xFF, 0x3B, 0xFF, 0xF4, 0x8E, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0xC9, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF4, 0xCF,
    0xFF, 0xF5, 0x10, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x0B, 0xFF, 0xFF, 0xBE, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFD, 0xF5, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x50, 0xF3, 0x26,
    0x10, 0xEB, 0x06, 0xFB, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xB4, 0xFF, 0xFF, 0x9E, 0xFF, 0xFF,
    0x5C, 0xFF, 0xF4, 0xCF, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x2B, 0xFF, 0xFF, 0x9D, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF,
    0xFF, 0xDE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x92, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFB, 0xF3, 0x26, 0x10, 0xEB, 0x06,
    0x00, 0x00, 0x00, 0xBB, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFD, 0xF4, 0xFF, 0xFF, 0x3B, 0xFF, 0xF5,
    0x10, 0xFF, 0xF3, 0x47, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xF4, 0xCF, 0xFF, 0xFE, 0x57, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x5C, 0xFF, 0xF4, 0xF0, 0xFF, 0xF4, 0x6D, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF4, 0xAE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB3, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xBB, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x5F, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xC9, 0xFF, 0xF4, 0x6C, 0xFF, 0xF3,
    0x68, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF4, 0x4C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0x15, 0xFF, 0xF4, 0x6D, 0xFF,
    0xFD, 0x72, 0xFF, 0xFE, 0x57, 0xFF, 0xFE, 0xB9, 0xFF, 0xFE, 0x98, 0xFF, 0xFD, 0xD4, 0xFF, 0xF4,
    0xAE, 0xFF, 0xF5, 0x31, 0xFF, 0xFF, 0x9D, 0xFF, 0xFE, 0x15, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x5F, 0xF3, 0x26, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x09, 0xE2, 0xA7, 0xEA, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xEA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0x1A, 0xFF, 0xFE, 0x15, 0xFF, 0xFD, 0xB3, 0xFF, 0xFD, 0xD4, 0xFF, 0xFE, 0x98, 0xFF, 0xFF,
    0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0xB4, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEA, 0xF3, 0x26, 0x09, 0xE2, 0xA7, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xA9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFD, 0x72, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0x7C, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0xEB, 0x07, 0xE7, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x67, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF5, 0x31, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xE7, 0xF3, 0x26, 0x0D, 0xEB, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5E, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF4, 0xEF, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0x5F, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB4, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xFE, 0x77, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x9D, 0xFF, 0xF3, 0xA9, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xB4, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x15, 0xF3, 0x06, 0xE2,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0xC9, 0xFF, 0xF3, 0xCA, 0xFF,
    0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3,
    0xCA, 0xFF, 0xF3, 0xCA, 0xFF, 0xF3, 0x67, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xE3, 0xF3,
    0x26, 0x15, 0xF3, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x34,
    0xF3, 0x26, 0xF3, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF3, 0xF3, 0x26, 0x34, 0xF3,
    0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x46, 0xF3, 0x26, 0xF7, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xF7, 0xF3, 0x26, 0x45, 0xF3, 0x26, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x43, 0xF3, 0x26, 0xF1, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xEF, 0xF3, 0x26, 0x3E, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0xF3, 0x26, 0xDA, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xDA, 0xF3, 0x26, 0x2D, 0xF3, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D, 0xEB, 0x07, 0xA4, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xA4,
    0xF3, 0x26, 0x0D, 0xFB, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x4C, 0xF3, 0x26, 0xDB, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xDB, 0xF3, 0x26, 0x4C, 0xF3, 0x46, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x05, 0xCB, 0x26, 0x64, 0xF3, 0x26, 0xD7, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26,
    0xFF, 0xF3, 0x26, 0xD7, 0xF3, 0x26, 0x64, 0xF3, 0x26, 0x05, 0xCB, 0x26, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x41, 0xF3, 0x26,
    0x9B, 0xF3, 0x26, 0xE8, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF,
    0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3,
    0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xFF, 0xF3, 0x26, 0xE8, 0xF3, 0x26, 0x9B, 0xF3, 0x26,
    0x41, 0xF3, 0x26, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0xF8, 0x00, 0x2B, 0xFB, 0x26, 0x62, 0xF3, 0x26, 0x8D, 0xF3, 0x26, 0xAD,
    0xF3, 0x26, 0xC2, 0xF3, 0x26, 0xCC, 0xF3, 0x26, 0xCC, 0xF3, 0x26, 0xC2, 0xF3, 0x26, 0xAD, 0xF3,
    0x26, 0x8D, 0xF3, 0x26, 0x62, 0xF3, 0x26, 0x2C, 0xF3, 0x46, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


#define DRAW_IMAGE              0x0
#define DRAW_IMAGE_WITH_ALPHA   0x1

struct image_buf {
    u8 *buf;
    u32 len;
};

static void ui_custom_draw_cb(int id, u8 *dst_buf, struct rect *dst_r, struct rect *src_r, u8 bytes_per_pixel, void *priv)
{
    int w, h;
    struct rect r;
    struct draw_context dc = {0};

    if (id == DRAW_IMAGE) {
        int dst_stride = (dst_r->width * bytes_per_pixel + 3) / 4 * 4;
        int src_stride = (src_r->width * bytes_per_pixel + 3) / 4 * 4;
        struct image_buf *image_b = (struct image_buf *)priv;
        /* printf("ui_custom_draw_cb 0x%x, %d\n", image_b->buf, image_b->len); */
        /* printf("dst [%d, %d, %d, %d],  src [%d, %d, %d, %d]\n", dst_r->left, dst_r->top, dst_r->width, dst_r->height, */
        /* src_r->left, src_r->top, src_r->width, src_r->height); */

        if (get_rect_cover(src_r, dst_r, &r)) {
            for (h = 0; h < r.height; h++) {
                memcpy(&dst_buf[(r.top + h - dst_r->top) * dst_stride + (r.left - dst_r->left) * 2],
                       &image_b->buf[(r.top + h - src_r->top) * src_stride + (r.left - src_r->left) * 2],
                       r.width * 2);
            }
        }
    } else if (id == DRAW_IMAGE_WITH_ALPHA) {
        int dst_stride = (dst_r->width * bytes_per_pixel + 3) / 4 * 4;
        /* int src_stride = (src_r->width * 3 + 3) / 4 * 4; */
        struct image_buf *image_b = (struct image_buf *)priv;
        u8 alpha;
        u16 forecolor;
        u16 backcolor;
        u16 mixedcolor;
        u32 offset_src;
        u32 offset_dst;

        if (get_rect_cover(src_r, dst_r, &r)) {
            for (h = 0; h < r.height; h++) {
                for (w = 0; w < r.width; w++) {
                    offset_src = (r.top + h - src_r->top) * src_r->width * 3 + (r.left + w - src_r->left) * 3;
                    alpha = image_b->buf[offset_src];
                    forecolor = (image_b->buf[offset_src + 1] << 8) | image_b->buf[offset_src + 2];

                    if (alpha) {
                        offset_dst = (r.top + h - dst_r->top) * dst_stride + (r.left + w - dst_r->left) * 2;
                        backcolor = (dst_buf[offset_dst + 1] << 8) | dst_buf[offset_dst];
                        mixedcolor = ui_draw_get_mixed_pixel((backcolor >> 8) | ((backcolor & 0xff) << 8), forecolor, alpha);
                        dst_buf[offset_dst] = mixedcolor;
                        dst_buf[offset_dst + 1] = mixedcolor >> 8;
                    }
                }
            }
        }
    }
}


void ui_draw_custom_rgb565(void *_dc, int x, int y, int width, int height, u8 *buf, u32 len)
{
    struct image_buf image_b;
    image_b.buf = buf;
    image_b.len = len;
    /* printf("ui_draw_custom_rgb565 0x%x, %d\n", image_b.buf, image_b.len); */
    ui_draw(_dc, NULL, x, y, width, height, ui_custom_draw_cb, &image_b, sizeof(struct image_buf), DRAW_IMAGE);
}

void ui_draw_custom_argb8565(void *_dc, int x, int y, int width, int height, u8 *buf, u32 len)
{
    struct image_buf image_b;
    image_b.buf = buf;
    image_b.len = len;
    /* printf("ui_draw_custom_argb8565 0x%x, %d\n", image_b.buf, image_b.len); */
    ui_draw(_dc, NULL, x, y, width, height, ui_custom_draw_cb, &image_b, sizeof(struct image_buf), DRAW_IMAGE_WITH_ALPHA);
}

#endif

/*
 * 说明：自定义绘图适用于所有控件，这里示例选用布局
 * */
static int DRAW_DEMO_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct element *elm = (struct element *)_ctrl;
    struct draw_context *dc = (struct draw_context *)arg;
    struct rect rect = {0};
    struct rect r = {0};
    struct image_file f;
    struct rect r1;
    int angle;
    int id;
    int i;

    switch (event) {
    case ON_CHANGE_INIT:
        break;
    case ON_CHANGE_SHOW:
#if defined(TCFG_UI_ENABLE_DEMO) && TCFG_UI_ENABLE_DEMO
        /*根据需要调用以下三个接口:ui_remove_backcolor,ui_remove_backimage,ui_remove_border*/
        ui_remove_backcolor(elm);//移除控件背景颜色
        ui_remove_backimage(elm);//移除控件背景图像
        ui_remove_border(elm);//移除控件边界
#endif
        break;
    case ON_CHANGE_SHOW_POST:
#if defined(TCFG_UI_ENABLE_DEMO) && TCFG_UI_ENABLE_DEMO
        ui_custom_draw_clear(dc);

        ui_core_get_element_abs_rect(elm->dc->elm, &r); //跟随控件移动,注释掉这句则不跟随控件移动
        ui_core_get_element_abs_rect(elm, &rect); //跟随控件移动,注释掉这句则不跟随控件移动
        rect.left -= r.left;
        rect.top -= r.top;

        /*
         * 以下绘图函数只能在该控件的范围内显示，超出控件区域不显示
         * */

        /* 矩形填充 */
        ui_fill_rect(dc, 100, 100, 254, 254, 0xffff);

        /* 指定角度画直线  */
        for (angle = 0; angle <= 360; angle += 45) {
            ui_draw_line_by_angle(dc, 227, 227, 100, angle, 0xf800);
        }

        /* 画矩形 */
        ui_draw_rect(dc, 125, 125, 204, 204, 0xf800);

        /* 画线段 */
        ui_draw_line(dc, 120, 120, 333, 120, 0x07e0);
        ui_draw_line(dc, 333, 120, 333, 333, 0x07e0);
        ui_draw_line(dc, 333, 333, 120, 333, 0x07e0);
        ui_draw_line(dc, 120, 333, 120, 120, 0x07e0);

        /* 画圆 */
        ui_draw_ring(dc, 227, 227, 102, 90, 0, 360, 0x003f, 100);

        /* 画圆环 */
        ui_draw_ring(dc, 227, 227, 117, 105, 0 + 135, 270 + 135, 0xc618, 100);
        ui_draw_ring(dc, 227, 227, 117, 105, 0 + 135, 270 + 135, 0xf800, 75);

        /* 画进度条 */
        ui_draw_bar(dc, 120, 380, 200, 25, RGB565(58, 63, 72), 100);
        ui_draw_bar(dc, 120, 380, 200, 25, 0xf800, 50);

        /* 显示缓存叠加图片 */
        ui_draw_custom_rgb565(dc, rect.left + 100, rect.top + 100, 48, 49, icon_48x49_rgb565, sizeof(icon_48x49_rgb565));

        /* 显示缓存叠加图片(带alpha) */
        ui_draw_custom_argb8565(dc, rect.left + 220, rect.top + 100, 48, 49, icon_48x49_argb8565, sizeof(icon_48x49_argb8565));

        /* 显示图片id到指定坐标 */
        id = PAGE17_3ec1_01_MENU_ICON_TRAINING_SEL_S5;
        open_image_by_id(0, NULL, &f, id & 0xffff, id >> 16);
        ui_draw_image(dc, id >> 16, id & 0xffff, (r.width - f.width) / 2, (r.height - f.height) / 2); //屏幕居中显示

        /* 显示多国语言文本 */
        ui_draw_strpic(dc, M26, 200, 280, RGB565(0, 0, 0));

        /* 显示ascii文本 */
        char *ascii = "0123456789";
        ui_draw_ascii(dc, ascii, strlen(ascii), 200, 296, RGB565(255, 0, 0));

        /* 显示字库文本 */
        char *text = "字库文本测试";
        ui_draw_text(dc, FONT_ENCODE_UTF8, 0, text, strlen(text), 200, 322, RGB565(255, 0, 0));
#endif
        break;

    case ON_CHANGE_RELEASE:
        break;
    default:
        break;
    }
    return false;
}

static int DRAW_DEMO_ontouch(void *_ctrl, struct element_touch_event *e)
{
    struct element *elm = (struct element *)_ctrl;
    struct rect rect;
    static struct position mem_pos = {0};
    int x_offset;
    int y_offset;
    int css_left;
    int css_top;
    struct element_css *css;

    switch (e->event) {
    case ELM_EVENT_TOUCH_DOWN:
        memcpy(&mem_pos, &e->pos, sizeof(struct position));
        return true;
    case ELM_EVENT_TOUCH_HOLD:
        break;
    case ELM_EVENT_TOUCH_MOVE:
        x_offset = e->pos.x - mem_pos.x;
        y_offset = e->pos.y - mem_pos.y;
        memcpy(&mem_pos, &e->pos, sizeof(struct position));
        ui_core_get_element_abs_rect(elm->parent, &rect);
        css_left = x_offset * 10000 / rect.width;
        css_top = y_offset * 10000 / rect.height;
        css = ui_core_get_element_css(elm);
        css->left += css_left;
        css->top += css_top;
        ui_core_redraw(elm->parent);
        break;
    case ELM_EVENT_TOUCH_UP:
        break;
    }
    return false;
}

REGISTER_UI_EVENT_HANDLER(DRAW_DEMO)
.onchange = DRAW_DEMO_onchange,
 .onkey = NULL,
  .ontouch = DRAW_DEMO_ontouch,
};

#if 0
#define ui_text_for_id(id) \
	({ \
		struct element *elm = ui_core_get_element_by_id(id); \
	 	elm ? container_of(elm, struct ui_text, elm): NULL; \
	 })
#define ui_number_for_id(id) \
    ({ \
        struct element *elm = ui_core_get_element_by_id(id); \
        elm ? (struct ui_number *)elm: NULL; \
     })

static int TEXT_TEST_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct ui_text *text = (struct ui_text *)ctr;
    static u8 time = 0;
    static u8 hour[24];
    static u8 num[24];
    static struct unumber n1, n2, n3;    //数字显示源

    //int language;
    switch (e) {
    case ON_CHANGE_INIT:
        /* ui_language_set(Arabic); */
        ui_language_set(Vietnam);
        //language = ui_language_get();
        ui_text_set_text_attrs(text, (char *)utf8_code, sizeof(utf8_code), FONT_ENCODE_UTF8, 0, FONT_DEFAULT);
        time++;
        n1.type = TYPE_NUM;
        n1.numbs = 1;
        n1.number[0] = rand32() % 100; //未读传感器值，这里用随机数代替，取余获取较小数值
        n2.type = TYPE_NUM;  //数据类型，分数字和字符串
        n2.numbs = 1;
        n2.number[0] = rand32() % 100;
        n3.type = TYPE_NUM;
        n3.numbs = 1;
        n3.number[0] = n1.number[0] / 2 + n2.number[0] / 2;
        num[time - 1] = n3.number[0];  //利用数组记录历史值，供下面循环使用
        hour[time - 1] = time - 1;
        ui_number_update(ui_number_for_id(HIGH_NUM), &n1);  //更新需要显示的数据源
        ui_number_update(ui_number_for_id(LOW_NUM), &n2);
        ui_number_update(ui_number_for_id(AVER_NUM), &n3);
        if (n3.number[0] <= 30) {
            ui_text_set_index(ui_text_for_id(STATE), 0);    //选择图片控件的偏移,不同的“压力值”对应不同图片
        } else if (n3.number[0] > 30 && n3.number[0] <= 50) {
            ui_text_set_index(ui_text_for_id(STATE), 1);
        } else if (n3.number[0] > 50 && n3.number[0] <= 80) {
            ui_text_set_index(ui_text_for_id(STATE), 2);
        } else {
            ui_text_set_index(ui_text_for_id(STATE), 3);
        }
        break;
    case ON_CHANGE_SHOW:
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(TEXT_TEST)
.onchange = TEXT_TEST_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};
#endif
const static u8 utf8_code[] = {
    /* 希伯来语测试 */
    /* 0xD7,0xAA,0xD7,0xA8,0xD7,0x92,0xD7,0x95, 0xD7,0x9D,0x20,0xD7,0xAA,0xD7,0x9E,0xD7, 0x95,0xD7,0xA0,0xD7,0xA6,0xD7,0x9C,0xD7, 0x9D,0x20,0xD7,0x90,0xD7,0x95, */
    /*  */
    /* 0x32,0x30,0x32,0x31,0xE5,0xB9,0xB4,0x38, 0xE6,0x9C,0x88, */
    /*  */
    /* 0xD7,0x9C,0xD7,0xA9,0xD7,0x95,0xD7,0xA0, 0xD7,0x99,0xD7,0x99,0xD7,0x9D,0x20,0xD7, 0x91,0xD7,0x96,0xD7,0x9E,0xD7,0x9F,0x20, 0xD7,0x90,0xD7,0x9E,0xD7,0xAA, */
    /*  */
    /* 0xEC,0x8B,0xA4,0xEF,0xBF,0xA5,0x40,0xE5, 0x93,0x8E,0xE5,0x91,0xA6,0x68,0x61,0x6C, 0x6F,0x20,0x77,0x6F,0x72,0x6C,0x64,0xE4, 0xB8,0x8D,0xE9,0x94,0x99,0xE5,0x93,0xA6, */
    /* 0x21,0xEA,0xB0,0x84,0xEC,0x9C,0xBC,0x3E, 0x3E, */
    /*  */
    /* 0xD7,0x93,0xD7,0x99,0xD7,0x90,0xD7,0x9C, 0xD7,0x95,0xD7,0x92,0xD7,0x99,0xD7,0x9D, */
    /*  */
    /* 0xE9,0x92,0xA2,0xE9,0x93,0x81,0xE4,0xBE, 0xA0,0x20,0x49,0x72,0x6F,0x6E,0x20,0x6D, 0x61,0x6E,0x20,0xE7,0x81,0xB5,0xE7,0xAC, 0xBC,0xEB,0xB2,0x88,0xEC,0x97,0xAD,0xEC, */
    /* 0x9D,0x84,0x20,0xEC,0x96,0xBB,0xEC,0x9D, 0x84,0xE7,0x99,0xBD,0xE6,0x9C,0x88,0xE9, 0xAD,0x81, */
    /*  */
    /* 0xD7,0x9C,0xD7,0xA9,0xD7,0x95,0xD7,0xA0, 0xD7,0x99,0xD7,0x99,0xD7,0x9D,0x20,0xD7, 0x91,0xD7,0x96,0xD7,0x9E,0xD7,0x9F, */
    /*  */
    /* 0x28,0x6E,0x75,0x6D,0x31,0x35,0x36,0x38, 0x31,0x31,0x36,0x38,0x31,0x30,0x31,0x29, */
    /*  */
    /* 0xD7,0xAA,0xD7,0xA8,0xD7,0x92,0xD7,0x95, 0xD7,0x9D,0x20,0xD7,0x93,0xD7,0x99,0xD7, 0x90,0xD7,0x9C,0xD7,0x95,0xD7,0x92,0x20 */
//俄语测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xD0,0xAE, 0x20,0xD0,0xAF,0x20,0xD0,0xB0,0x20,0xD0, */
    /* 0xB1,0x20,0xD0,0xB2,0x20,0xD0,0xB3,0x20, 0xD0,0xB4,0x20,0xD0,0xB5,0x20,0xD1,0x91, 0x20,0xD0,0xB6,0x20,0xD0,0xB7,0x20,0xD0, 0xB8,0x20,0xD0,0xB9,0xE4,0xBD,0xA0,0xE5, */
    /* 0xA5,0xBD,0xE7,0x8F,0xA0,0xE6,0xB5,0xB7, 0xEF,0xBC,0x81,0x20,0xD0,0xBA,0x20,0xD0, 0xBB,0x20,0xD0,0xBC,0x20,0xD0,0xBD,0x20, 0xD0,0xBE,0x20,0xD0,0xBF,0x20,0xD1,0x80, */
    /* 0x20,0xD1,0x81,0x20,0xD1,0x82,0x20,0xD1, 0x83,0x20,0xD1,0x84,0x20,0xD1,0x85,0x20, 0xD1,0x86,0x20,0xD1,0x87,0x20,0xD1,0x88, 0x20,0xD1,0x89,0x20,0xD1,0x8A,0x20,0xD1, */
    /* 0x8B,0x20,0xD1,0x8C,0x20,0xD1,0x8D,0x20, 0xD1,0x8E,0x20,0xD1,0x8F,0x20 */
//CP1250代码页语言测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xC3,0xA4, 0x2C,0xC3,0xB6,0x2C,0xC3,0xBC,0x2C,0xC3, */
    /* 0x9F,0x2E,0xE4,0xBD,0xA0,0xE5,0xA5,0xBD, 0xE7,0x8F,0xA0,0xE6,0xB5,0xB7,0xEF,0xBC, 0x81,0xC4,0x8C,0x20,0xCB,0x87,0x4E,0xCB, 0x87,0x20,0x4F,0x20,0x50,0x20,0x51,0x20, */
    /* 0x52,0x20,0xC5,0x98,0x20,0x53,0x20,0xC5, 0xA0,0x20,0x54,0x20,0x54,0xCB,0x87,0x20, 0x5A,0xCB,0x87,0x20,0xC4,0x87,0x2C,0x20, 0xC5,0x84,0x2C,0x20,0xC3,0xB3,0x2C,0x20, */
    /* 0xC5,0x9B,0x2C,0x20,0xC5,0xBA,0x20,0xC5, 0xBC,0x20,0xC4,0x85,0x2C,0x20,0xC4,0x99, 0x20,0xC5,0x82,0x20,0xC3,0xA1,0x2C,0x20, 0xC3,0xA9,0x2C,0x20,0xC3,0xAD,0x2C,0x20, */
    /* 0xC3,0xB3,0x2C,0xC3,0xBA,0x2C,0xC3,0xB6, 0x20,0xC5,0x91,0x20,0xC5,0xB1,0x20,0xC3, 0xBC,0x20,0xEA,0xB8,0x89,0xED,0x95,0x9C, 0xE4,0xB8,0xAD,0xE5,0x9B,0xBD,0x20 */
//CP1252代码页语言测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xC3,0xA4, 0x2C,0xC3,0xB6,0x2C,0xC3,0xBC,0x2C,0xC3, */
    /* 0x9F,0x2E,0xE4,0xBD,0xA0,0xE5,0xA5,0xBD, 0xE7,0x8F,0xA0,0xE6,0xB5,0xB7,0xEF,0xBC, 0x81,0xC3,0xA4,0x2C,0x20,0xC3,0xAB,0x2C, 0x20,0xC3,0xAF,0x2C,0x20,0xC3,0xB6,0x20, */
    /* 0x2C,0xC3,0xBC,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0xC3,0xA1,0x2C,0x20,0xC3,0xA9,0x2C, 0xC3,0xAD,0x2C,0x20,0xC3,0xB3,0x2C,0xC3, 0xBA,0x2C,0x20,0xC3,0xBD,0x2C,0x20,0xC3, */
    /* 0xB1,0x2C,0x20,0xC3,0xAF,0x2C,0x20,0xC3, 0xBC,0x2C,0xE4,0xB8,0xAD,0xE5,0x9B,0xBD, 0x20,0xC3,0xA9,0x2C,0x20,0xC3,0xAD,0x2C, 0xC3,0xB3,0x2C,0xC3,0xBA,0x2C,0xC3,0xA0, */
    /* 0x2C,0x20,0xC3,0xA8,0x2C,0x20,0xC3,0xAC, 0x2C,0xC3,0xB2,0x2C,0xC3,0xB9,0x20,0xC3, 0xA1,0x2C,0x20,0xC3,0xA2,0x2C,0xC3,0xA3, 0x2C,0x20,0xC3,0xA0,0x2C,0x20,0xC3,0xA7, */
    /* 0x2C,0xC3,0xA9,0x2C,0xC3,0xAA,0x2C,0xC3, 0xAD,0x2C,0xC3,0xB3,0x2C,0xC3,0xB4,0x2C, 0xC3,0xB5,0x2C,0xC3,0xBA,0x2E,0xC3,0xA0, 0x2C,0x20,0xC3,0xA8,0x2C,0x20,0xC3,0xB9, */
    /* 0x2C,0x20,0xC3,0xA2,0x2C,0xC3,0xAA,0x2C, 0xC3,0xAE,0x2C,0xC3,0xB4,0x2C,0xC3,0xBB, 0x2C,0xC3,0xA9,0x2C,0xC3,0xAB,0x2C,0xC3, 0xAF,0x2C,0xC3,0xBC,0x2C,0xC3,0xBF,0xC3, */
    /* 0xA7,0x2C,0xC3,0xA6,0xC5,0x93,0x2C,0xC3, 0x85,0x2C,0xC3,0x84,0x2C,0xC3,0x96,0x2C, 0xC3,0x85,0xC3,0xA6,0xC3,0x98,0xC3,0xA9, 0xC3,0xB3,0x20 */
//泰语测试编码
    /*     0xEC,0x96,0xB8,0xEA,0xB8,0x89,0xED,0x95, 0x9C,0x20,0x68,0x65,0x6C,0x6C,0x6F,0x20, 0x43,0x68,0x69,0x6E,0x61,0x20,0xE0,0xB9, 0x80,0xE0,0xB8,0x9B,0xE0,0xB9,0x87,0xE0, */
    /* 0xB8,0x99,0xE0,0xB8,0xA1,0xE0,0xB8,0xB9, 0xE0,0xB8,0xA5,0xE4,0xB8,0xAD,0xE5,0x9B, 0xBD,0xE0,0xB8,0x84,0xE0,0xB9,0x88,0xE0, 0xB8,0xB2,0xE0,0xB8,0x81,0xE0,0xB8,0xB2, */
    /* 0xE0,0xB8,0xA3,0xE0,0xB8,0x81,0xE0,0xB8, 0xA5,0xE0,0xB9,0x88,0xE0,0xB8,0xB2,0xE0, 0xB8,0xA7,0xE0,0xB8,0x82,0xE0,0xB8,0xA7, 0xE0,0xB8,0xB1,0xE0,0xB8,0x8D,0xE0,0xB8, */
    /* 0xA7,0xE0,0xB9,0x88,0xE0,0xB8,0xB2,0xE0, 0xB9,0x83,0xE0,0xB8,0x99,0xE0,0xB8,0x9A, 0xE0,0xB8,0xA3,0xE4,0xBD,0xA0,0xE5,0xA5, 0xBD,0xE7,0x8F,0xA0,0xE6,0xB5,0xB7,0xEF, */
    /* 0xBC,0x81,0xE0,0xB8,0xA3,0xE0,0xB8,0x94, 0xE0,0xB8,0xB2,0xE0,0xB8,0xAB,0xE0,0xB9, 0x89,0xE0,0xB8,0xB2,0xE0,0xB8,0x9B,0xE0, 0xB8,0xA3,0xE0,0xB8,0xB0,0xE0,0xB9,0x80, */
    /* 0xE0,0xB8,0x97,0xE0,0xB8,0xA8,0xE0,0xB8, 0x99,0xE0,0xB8,0xAD,0xEA,0xB8,0x89,0xED, 0x95,0x9C,0x20 */
//越南语测试编码
    /* 0x54, 0x68, 0xE1, 0xBB, 0x8B, 0x20, 0x74, 0x72, 0xE1, 0xBA, 0xA5, 0x6E, 0x20, 0xE6, 0x88, 0x91, 0xE6, 0x98, 0xAF, 0xE4, 0xB8, 0x80, 0xE4, 0xB8, 0xAA, 0xE6, 0x88, 0x98, 0xE5, 0xA3, 0xAB, 0x2C, */
    /* 0x45, 0x6E, 0x67, 0x6C, 0x69, 0x73, 0x68, 0x20, 0xEC, 0x93, 0xB0, 0xEC, 0xB4, 0xA8, 0xEC, 0x84, 0xB1, 0x20, 0x3E, 0x3E, 0x20, 0x53, 0x68, 0x75, 0x69, 0x6E, 0x61, 0x6E, 0x2C, 0x20, 0xE7, 0x99, */
    /* 0xBD, 0xE6, 0x9C, 0x88, 0xE9, 0xAD, 0x81, 0x20, 0x68, 0x75, 0x79, 0xE1, 0xBB, 0x87, 0x6E, 0x20, 0xEB, 0x84, 0xA4, 0xEC, 0x9D, 0xB4, 0xEC, 0x9E, 0xA5, 0x20, 0xE4, 0xBA, 0x91, 0xE6, 0x9B, 0xA6, */
    /* 0x2C, 0x20, 0x49, 0x20, 0x61, 0x6D, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x61, 0x74, 0x68, 0x20, 0xE6, 0x80, 0x95, 0xE7, 0x9A, */
    /* 0x84, 0xE4, 0xB8, 0x8D, 0xE6, 0x98, 0xAF, 0xE6, 0xAD, 0xBB, 0x2A, 0x2A, 0x25, 0xEF, 0xBF, 0xA5, 0x40, 0xEF, 0xBC, 0x8C, 0x74, 0x68, 0xC3, 0xA0, 0x6E, 0x68, 0x20, 0xE7, 0x81, 0xB5, 0xE7, 0xAC, */
    /* 0xBC, 0x20, 0x70, 0x68, 0xE1, 0xBB, 0x91, 0x58, 0x75, 0x79, 0xC3, 0xAA, 0x6E, 0x20, 0x54, 0xC3, 0xA2, 0x6E, 0x20, 0xE8, 0x80, 0x8C, 0xE6, 0x98, 0xAF, 0xE6, 0xB2, 0xA1, 0xE6, 0x9C, 0x89, 0xEC, */
    /* 0xA4, 0x91, 0xED, 0x98, 0x84, 0x20, 0xEC, 0x8A, 0x88, 0xEC, 0x9D, 0xB4, 0xEB, 0x82, 0x9C, 0xEC, 0xA7, 0x84, 0xE7, 0x9C, 0x9F, 0xE6, 0xAD, 0xA3, 0xE7, 0x9A, 0x84, 0xE6, 0xB4, 0xBB, 0xE8, 0xBF, */
    /* 0x87, 0x20, 0x47, 0x69, 0x61, 0x6E, 0x67, 0x2C, 0x20, 0x74, 0xE1, 0xBB, 0x89, 0x6E, 0x68, 0x20, 0xE7, 0xBA, 0xA2, 0xE5, 0xAF, 0x87, 0x20, 0x54, 0xE1, 0xBB, 0xA9, 0x20, 0x45, 0x6E, 0x67, 0x6C, */
    /* 0x69, 0x73, 0x68, 0x20, 0x58, 0x75, 0x79, 0xC3, 0xAA, 0x6E, 0x20 */
//阿拉伯语测试编码
    0xD8, 0xA3, 0xD9, 0x86, 0xD8, 0xA7, 0x20, 0xD9, 0x85, 0xD9, 0x82, 0xD8, 0xA7, 0xD8, 0xAA, 0xD9, 0x84, 0x20, 0xD8, 0x8C, 0x20, 0xD9, 0x88, 0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA, 0x20, 0xD8, 0xAE,
    0xD8, 0xA7, 0xD8, 0xA6, 0xD9, 0x81, 0xD9, 0x8B, 0xD8, 0xA7,

    0xE6, 0x88, 0x91, 0xE6, 0x98, 0xAF, 0xE4, 0xB8, 0x80, 0xE4, 0xB8, 0xAA, 0xE6, 0x88, 0x98, 0xE5, 0xA3, 0xAB, 0x3C, 0x49, 0x4E, 0x43, 0x41, 0x52, 0x4E, 0x41, 0x54, 0x49, 0x4F, 0x4E, 0x3E, 0xEB,
    0x91, 0x90, 0xEB, 0xA0, 0xA4, 0xEC, 0x9B, 0x8C, 0xED, 0x95, 0x98, 0xEC, 0xA7, 0x80, 0xEC, 0x95, 0x8A, 0xEC, 0xA7, 0x80,

    0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x8A, 0xEC, 0xA0, 0x84, 0xEC, 0x82, 0xAC, 0xEC, 0x9D, 0xB4, 0xEA, 0xB3, 0xA0, 0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA,

    0xE6, 0x80, 0x95, 0xE7, 0x9A, 0x84, 0x28, 0x25, 0x25, 0x46, 0x61, 0x6B, 0x65, 0x26, 0x26, 0x29, 0xE4, 0xB8, 0x8D, 0xE6, 0x98, 0xAF, 0xE6, 0xAD, 0xBB, 0xEF, 0xBC, 0x8C, 0xE8, 0x80, 0x8C, 0xE6,
    0x98, 0xAF, 0xE6, 0xB2, 0xA1, 0xE6, 0x9C, 0x89,

    0x49, 0x20, 0x61, 0x6D, 0x20, 0x6E, 0x6F, 0x74, 0x20, 0x61, 0x66, 0x72, 0x61, 0x69, 0x64, 0x20, 0x6F, 0x66, 0x20, 0x64, 0x65, 0x61, 0x74, 0x68, 0x2C, 0x20, 0x62, 0x75, 0x74, 0x20, 0x6E, 0x6F,
    0x74, 0x20, 0x72, 0x65, 0x61, 0x6C, 0x6C, 0x79, 0x20, 0x6C, 0x69, 0x76, 0x69, 0x6E, 0x67, 0x2E,

    0xD9, 0x85, 0xD9, 0x86, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x85, 0xD9, 0x88, 0xD8, 0xAA, 0x20, 0xD8, 0x8C, 0x20, 0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x8A,

    0xE7, 0x9C, 0x9F, 0xE6, 0xAD, 0xA3, 0xE7, 0x9A, 0x84, 0xEB, 0x8B, 0x99, 0xEB, 0x8B, 0x88, 0xEB, 0x8B, 0xA4, 0xE6, 0xB4, 0xBB, 0xE8, 0xBF, 0x87, 0xEF, 0xBC, 0x81,

    0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA, 0x20, 0xD8, 0xAE, 0xD8, 0xA7, 0xD8, 0xA6, 0xD9, 0x81, 0xD9, 0x8B, 0xD8, 0xA7, 0x20, 0xD9, 0x85, 0xD9, 0x86, 0x20, 0xD8, 0xA7, 0xD9, 0x84, 0xD9, 0x85, 0xD9,
    0x88, 0xD8, 0xAA, 0x20, 0xD8, 0x8C, 0x20, 0xD9, 0x84, 0xD9, 0x83, 0xD9, 0x86, 0xD9, 0x86, 0xD9, 0x8A, 0x20, 0xD9, 0x84, 0xD8, 0xB3, 0xD8, 0xAA, 0x20, 0xD8, 0xAE, 0xD8, 0xA7, 0xD8, 0xA6, 0xD9,
    0x81, 0xD9, 0x8B, 0xD8, 0xA7, 0x20, 0xD8, 0xAD, 0xD9, 0x82, 0xD9, 0x8B, 0xD8, 0xA7, 0x2E, 0x20
};

static int TEXT_TEST_onchange(void *ctr, enum element_change_event e, void *arg)
{
    struct ui_text *text = (struct ui_text *)ctr;
    //int language;
    switch (e) {
    case ON_CHANGE_INIT:
        ui_language_set(Arabic);
        /* 当前显示不同语言只需设置语言地区及更换字符编码即可 */
        /* ui_language_set(Polish);  //设置当前待显示字符的地区，共用1252的用Danish，1250的用Polish */
        //language = ui_language_get();
        ui_text_set_text_attrs(text, (char *)utf8_code, sizeof(utf8_code), FONT_ENCODE_UTF8, 0, FONT_DEFAULT);
        break;
    case ON_CHANGE_SHOW:
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(TEXT_TEST)
.onchange = TEXT_TEST_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


#if 0
static int text_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;
    static u8 *name_p = "liangweixin@jh-jieli.com";
    /* static u8 *name_p = "lian"; */

    switch (event) {
    case ON_CHANGE_INIT:
        ui_text_set_text_attrs(text, name_p, strlen(name_p), FONT_ENCODE_UTF8, 0, FONT_DEFAULT);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}
REGISTER_UI_EVENT_HANDLER(TEXT_TEST)
.onchange = text_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif


#if 1
static int ascii_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;

    switch (event) {
    case ON_CHANGE_INIT:
        ui_text_set_str(text, "ascii", "liangweixin", strlen("liangweixin"), FONT_DEFAULT);
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(ASCII_TEST)
.onchange = ascii_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

/*文本控件多字符串组合显示示例*/
static int mulstr_test_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_text *text = (struct ui_text *)_ctrl;
    u8 index_buf[7] ALIGNED(4);
    static u16 store_buf[7 * 2 + 2] ALIGNED(4);

    switch (event) {
    case ON_CHANGE_INIT:
        /* 一二三四五六日 */
        index_buf[0] = 0;//一
        index_buf[1] = 1;//二
        index_buf[2] = 2;//三
        index_buf[3] = 3;//四
        index_buf[4] = 4;//五
        index_buf[5] = 5;//六
        index_buf[6] = 6;//日
        ui_text_set_combine_index(text, store_buf, index_buf, 7);
        /* store_buf[0] = 216; */
        /* store_buf[1] = 217; */
        /* store_buf[2] = 218; */
        /* store_buf[3] = 219; */
        /* store_buf[4] = 220; */
        /* store_buf[5] = 221; */
        /* store_buf[6] = 222; */
        for (u8 i = 0; i < sizeof(store_buf); i++) {
            y_printf("store_buf[%d]:%d", i, store_buf[i]);
        }
        break;
    case ON_CHANGE_RELEASE:
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(MULSTR_TEST)
.onchange = mulstr_test_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

void NUM_TEST_timer(void *priv)
{
    if (!watch_num_test_timer) {
        return ;
    }
    struct unumber n;
    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = rand32();
    ui_number_update_by_id(NUM_TEST, &n);
}

static int NUM_TEST_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_ctrl;
    struct unumber n;
    switch (event) {
    case ON_CHANGE_INIT:
        n.type = TYPE_NUM;
        n.numbs = 1;
        n.number[0] = rand32();
        ui_number_update(number, &n);
        if (!watch_num_test_timer) {
            watch_num_test_timer = sys_timer_add(NULL, NUM_TEST_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_test_timer) {
            sys_timer_del(watch_num_test_timer);
            watch_num_test_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}


REGISTER_UI_EVENT_HANDLER(NUM_TEST)
.onchange = NUM_TEST_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


#if OLDER_STYLE

static void NUM_1_timer(void *priv)
{
    struct unumber n = {0};
    static int steps = 0;
    if (!watch_num_1_timer) {
        return ;
    }

    steps++;
    if (steps > 1000) {
        steps = 0;
    }

    n.type = TYPE_NUM;
    n.numbs = 1;
    n.number[0] = steps;
    ui_number_update_by_id(PRESSURE_NUM_1, &n);
}


static int NUM_1_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.steps = 0;
        number->nums = 1;
        number->number[0] = progress_record.steps;

        if (!watch_num_1_timer) {
            watch_num_1_timer = sys_timer_add(NULL, NUM_1_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_1_timer) {
            sys_timer_del(watch_num_1_timer);
            watch_num_1_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(PRESSURE_NUM_1)
.onchange = NUM_1_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};


static void NUM_2_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_2_timer) {
        return;
    }
    this->min++;
    if (this->min > 30) {
        this->min = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 2;
    n.number[0] = this->min;
    n.number[1] = this->target_min;
    ui_number_update_by_id(PRESSURE_NUM_2, &n);
    percent = this->min * 100 / this->target_min;
}

static int NUM_2_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.min = 0;
        progress_record.target_min = 30;
        number->nums = 2;
        number->number[0] = progress_record.min;
        number->number[1] = progress_record.target_min;
        if (!watch_num_2_timer) {
            watch_num_2_timer = sys_timer_add(&progress_record, NUM_2_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_2_timer) {
            sys_timer_del(watch_num_2_timer);
            watch_num_2_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(PRESSURE_NUM_2)
.onchange = NUM_2_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};



static void NUM_3_timer(void *priv)
{
    static int last_percent = 0;
    struct progress_record_priv *this = (struct progress_record_priv *)priv;
    int percent;
    static struct unumber n;

    if (!watch_num_3_timer) {
        return ;
    }
    this->times++;
    if (this->times > 12) {
        this->times = 0;
    }
    n.type = TYPE_NUM;
    n.numbs = 2;
    n.number[0] = this->times;
    n.number[1] = this->target_times;
    ui_number_update_by_id(PRESSURE_NUM_3, &n);
    percent = this->times * 100 / this->target_times;
}

static int NUM_3_onchange(void *_number, enum element_change_event event, void *arg)
{
    struct ui_number *number = (struct ui_number *)_number;

    switch (event) {
    case ON_CHANGE_INIT:
        progress_record.times = 0;
        progress_record.target_times = 12;
        number->nums = 2;
        number->number[0] = progress_record.times;
        number->number[1] = progress_record.target_times;
        if (!watch_num_3_timer) {
            watch_num_3_timer = sys_timer_add(&progress_record, NUM_3_timer, 1000);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_num_3_timer) {
            sys_timer_del(watch_num_3_timer);
            watch_num_3_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

REGISTER_UI_EVENT_HANDLER(PRESSURE_NUM_3)
.onchange = NUM_3_onchange,
 .onkey = NULL,
  .ontouch = NULL,
};

#endif

static void BT_COMPASS_timer(void *priv)
{
    if (!watch_bt_compass_timer) {
        return;
    }
    static int bk_angle = 0;
    static int ind_angle = 0;
    int sign = rand32() % 2;

    bk_angle = sign ? 360 - (rand32() % 180) : rand32() % 180;

    ui_io_set(IO_FRAME, HIGH);
    ui_compass_set_angle_by_id(BT_COMPASS, bk_angle, ind_angle);
    ui_io_set(IO_FRAME, LOW);

    /* bk_angle += 6; */
    /* if (bk_angle >= 360) { */
    /* bk_angle = 0; */
    /* } */
}

static int BT_COMPASS_onchange(void *_ctrl, enum element_change_event event, void *arg)
{
    struct ui_compass *compass = (struct ui_compass *)_ctrl;

    switch (event) {
    case ON_CHANGE_INIT:
        if (!watch_bt_compass_timer) {
            watch_bt_compass_timer = sys_timer_add(NULL, BT_COMPASS_timer, 100);
        }
        break;
    case ON_CHANGE_RELEASE:
        if (watch_bt_compass_timer) {
            sys_timer_del(watch_bt_compass_timer);
            watch_bt_compass_timer = 0;
        }
        break;
    default:
        return FALSE;
    }
    return FALSE;
}

static int BT_COMPASS_ontouch(void *ctrl, struct element_touch_event *e)
{
    switch (e->event) {
    case ELM_EVENT_TOUCH_R_MOVE:
        ui_return_page_pop(1);
        break;
    }
    return false;
}

REGISTER_UI_EVENT_HANDLER(BT_COMPASS)
.onchange = BT_COMPASS_onchange,
 .onkey = NULL,
  .ontouch = BT_COMPASS_ontouch,
};

#endif

static int pic_sys_reboot_and_shutdown_ontouch(void *_ctrl, struct element_touch_event *e)
{
    static u8 touch_action = 0;
    struct ui_pic *pic = (struct ui_pic *)_ctrl;
    switch (e->event) {
    case ELM_EVENT_TOUCH_UP:
        if (touch_action != 1) {
            break;
        }
        switch (pic->elm.id) {
        case PIC_SYS_REBOOT:
            extern int lcd_drv_power_ctrl(u8 on);
            lcd_drv_power_ctrl(false);
            watch_reboot_or_shutdown(1, 0);
            break;
        case PIC_SYS_SHUTDOWN:
            watch_reboot_or_shutdown(0, 0);
            break;
        }
        break;
    case ELM_EVENT_TOUCH_DOWN:
        touch_action = 1;
        return true;
    case ELM_EVENT_TOUCH_MOVE:
        touch_action = 2;
        break;
    case ELM_EVENT_TOUCH_R_MOVE:
        UI_HIDE_CURR_WINDOW();
        UI_SHOW_WINDOW(ID_WINDOW_BT);
        break;
    }
    return false;
}
REGISTER_UI_EVENT_HANDLER(PIC_SYS_REBOOT)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = pic_sys_reboot_and_shutdown_ontouch,
};
REGISTER_UI_EVENT_HANDLER(PIC_SYS_SHUTDOWN)
.onchange = NULL,
 .onkey = NULL,
  .ontouch = pic_sys_reboot_and_shutdown_ontouch,
};

#endif
#endif /* #if (!TCFG_LUA_ENABLE) */


